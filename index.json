[{"uri":"/Teaching/Common.html","title":"Common","content":"#r \u0022nuget: FSharp.Data\u0022\n\nopen System\nopen System.IO\nopen FSharp.Data\n\nEnvironment.CurrentDirectory \u003C- __SOURCE_DIRECTORY__\n\nmodule Secrets =\n    let envVars = System.Environment.GetEnvironmentVariables() \n    let localPath = \u0022../secrets.fsx\u0022\n    let localPath2 = \u0022secrets.fsx\u0022\n    let tiingoKey = \n        let var = \u0022TIINGO_KEY\u0022\n        if envVars.Contains var then \n            envVars.[var] :?\u003E string\n        elif File.Exists(localPath) then \n            File.ReadAllText(localPath)\n                .Replace(\u0022let tiingoKey = \u0022,\u0022\u0022)\n                .Replace(\u0022\\\u0022\u0022,\u0022\u0022)\n        else \n            File.ReadAllText(localPath2)\n                .Replace(\u0022let tiingoKey = \u0022,\u0022\u0022)\n                .Replace(\u0022\\\u0022\u0022,\u0022\u0022)\n    \n\n\ntype Frequency = Daily | Monthly\ntype ReturnObs = { Symbol : string; Date : DateTime; Return : float }\n\nmodule Tiingo =\n\n    type TiingoCsv = CsvProvider\u003C\u0022date,close,high,low,open,volume,adjClose,adjHigh,adjLow,adjOpen,adjVolume,divCash,splitFactor\n2020-10-01,9.77,10.25,9.69,10.09,4554055,9.77,10.25,9.69,10.09,4554055.0,0.0,1.0\u0022\u003E\n\n    type TiingoRequest = { Symbol : string; Start : DateTime; End : DateTime }\n\n    type TiingoObs =\n        {\n            Date : DateTime\n            Close : decimal\n            High : decimal\n            Low : decimal\n            Open : decimal \n            Volume : int\n            AdjClose : decimal\n            AdjHigh : decimal\n            AdjLow : decimal\n            AdjOpen : decimal\n            AdjVolume : decimal\n            DivCash : decimal\n            SplitFactor : decimal\n        }\n\n    ///\u003Csummary\u003EConstructs a Tiingo request. By default is to get the past year of data.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022symbol\u0022\u003EThe ticker symbol such as \u0022AAPL\u0022,\u0022MSFT\u0022 etc.\u003C/param\u003E\n    let request symbol = { Symbol = symbol; Start = DateTime.Now.AddYears(-1); End = DateTime.Now}\n    ///\u003Csummary\u003ESets the Tiingo request start date.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022startOn\u0022\u003ERequest start date\u003C/param\u003E\n        /// \u003Cparam name=\u0022request\u0022\u003EThe Tiingo request to update.\u003C/param\u003E\n    let startOn startOn request = { request with Start = startOn }\n    ///\u003Csummary\u003ESets the Tiingo request end date.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022endOn\u0022\u003ERequest start date\u003C/param\u003E\n        /// \u003Cparam name=\u0022request\u0022\u003EThe Tiingo request to update.\u003C/param\u003E\n    let endOn endOn request = { request with End = endOn }\n\n    let private cache = Runtime.Caching.createInMemoryCache (TimeSpan(hours=12,minutes=0,seconds=0))\n\n    ///\u003Csummary\u003EDownloads Tiingo data.\u003C/summary\u003E\n        /// \u003Cparam name=\u0022request\u0022\u003EThe Tiingo request to download.\u003C/param\u003E\n    let get request =\n        let dtStr (x : DateTime) = x.Date.ToString(\u0022yyyy-MM-dd\u0022)\n        let request = { request with Start = request.Start.Date; End = request.End.Date }\n        let key = $\u0022{request.Symbol}-{dtStr request.Start}-{dtStr request.End}.csv\u0022\n        match cache.TryRetrieve(key) with\n        | Some res -\u003E res\n        | None -\u003E\n            let result = \n                Http.RequestString\n                            ( $\u0022https://api.tiingo.com/tiingo/daily/{request.Symbol}/prices\u0022, \n                                httpMethod = \u0022GET\u0022,\n                                query   = [ \u0022token\u0022, Secrets.tiingoKey; \n                                            \u0022startDate\u0022, request.Start.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022endDate\u0022, request.End.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022format\u0022,\u0022csv\u0022],\n                                headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv])\n            cache.Set(key,result)\n            result\n        |\u003E TiingoCsv.Parse\n        |\u003E fun parsed -\u003E\n            parsed.Rows\n            |\u003E Seq.map(fun row -\u003E\n                { Date = row.Date\n                  Close = row.Close\n                  High = row.High\n                  Low = row.Low\n                  Open = row.Open\n                  Volume = row.Volume\n                  AdjClose = row.AdjClose\n                  AdjHigh = row.AdjHigh\n                  AdjLow = row.AdjLow\n                  AdjOpen = row.AdjOpen\n                  AdjVolume = row.AdjVolume\n                  DivCash = row.DivCash\n                  SplitFactor = row.SplitFactor \n                  })\n            |\u003E Seq.toArray      \n    \n    // using a class, keeping private for now.\n    type private Download(symbol:string,?startOn:DateTime,?endOn:DateTime) =\n        let startOn = defaultArg startOn (DateTime.Now.AddYears(-1))\n        let endOn = defaultArg endOn (DateTime.Now)\n        let data = get { Symbol = symbol; Start = startOn; End = endOn }\n        member this.Rows = data\n \n    // Probably deprecated\n    let private getFromCacheDirectory cacheDirectory request =\n        let dtStr (x : DateTime) = x.Date.ToString(\u0022yyyy-MM-dd\u0022)\n        let request = { request with Start = request.Start.Date; End = request.End.Date }\n        let key = $\u0022{request.Symbol}-{dtStr request.Start}-{dtStr request.End}.csv\u0022\n        let cacheFile = cacheDirectory \u002B key\n        if File.Exists(cacheFile) then\n            File.ReadAllText(cacheFile)\n        else    \n            let result = \n                Http.RequestString\n                            ( $\u0022https://api.tiingo.com/tiingo/daily/{request.Symbol}/prices\u0022, \n                                httpMethod = \u0022GET\u0022,\n                                query   = [ \u0022token\u0022, Secrets.tiingoKey; \n                                            \u0022startDate\u0022, request.Start.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022endDate\u0022, request.End.ToString(\u0022yyyy-MM-dd\u0022);\n                                            \u0022format\u0022,\u0022csv\u0022],\n                                headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv])\n            File.WriteAllText(cacheFile,result)\n            result\n        |\u003E TiingoCsv.Parse\n    \n    let private returnHelper symbol (xs:TiingoObs seq) =\n        xs\n        |\u003E Seq.sortBy(fun x -\u003E x.Date)\n        |\u003E Seq.pairwise\n        |\u003E Seq.map(fun (yesterday, today) -\u003E\n            { Symbol = symbol \n              Date = today.Date\n              Return =  float (today.AdjClose / yesterday.AdjClose) - 1.0})\n        |\u003E Seq.toArray      \n\n    let getReturns request =\n        get request\n        |\u003E (returnHelper request.Symbol)\n\n    // Marking as private so people don\u0027t use it by accident\n    let private getInternetFileCache request =\n        let cache = Runtime.Caching.createInternetFileCache \u0022tiingo\u0022 (TimeSpan.FromDays 30.0)\n        let request = { request with Start = request.Start.Date; End = request.End.Date }\n        let key = request.ToString()\n        match cache.TryRetrieve(key) with\n        | Some res -\u003E res\n        | None -\u003E\n            let res =\n                Http.RequestString\n                        ( $\u0022https://api.tiingo.com/tiingo/daily/{request.Symbol}/prices\u0022, \n                            httpMethod = \u0022GET\u0022,\n                            query   = [ \u0022token\u0022, Secrets.tiingoKey; \n                                        \u0022startDate\u0022, request.Start.ToString(\u0022yyyy-MM-dd\u0022);\n                                        \u0022endDate\u0022, request.End.ToString(\u0022yyyy-MM-dd\u0022);\n                                        \u0022format\u0022,\u0022csv\u0022],\n                            headers = [HttpRequestHeaders.Accept HttpContentTypes.Csv ])\n            cache.Set(key, res)\n            res\n        |\u003E TiingoCsv.Parse\n\nmodule French =\n    //open System.Net\n    open System.IO.Compression\n\n    type private FF3Csv = CsvProvider\u003C\u0022Date (string),Mkt-RF,SMB,HML,RF\n        19260701,    0.10,   -0.24,   -0.28,   0.009\u0022\u003E\n    type FF3Obs = \n        { Date : DateTime \n          MktRf : float\n          Smb : float \n          Hml : float\n          Rf : float \n          Frequency : Frequency } \n\n    type private FF5Csv = CsvProvider\u003C\u0022Date (string),Mkt-RF,SMB,HML,RMW,CMA,RF\n        19260701,    0.10,   -0.24,   -0.28,0.0,1.2,  0.009\u0022\u003E\n\n    type FF5Obs = \n        { Date : DateTime \n          MktRf : float\n          Smb : float \n          Hml : float\n          Rmw : float\n          Cma : float\n          Rf : float \n          Frequency : Frequency } \n\n    let private frenchDay x = \n        DateTime.ParseExact(x,\n            \u0022yyyyMMdd\u0022,\n            Globalization.CultureInfo.InvariantCulture)\n    let private frenchMonth x = \n        DateTime.ParseExact(x,\n            \u0022yyyyMM\u0022,\n            Globalization.CultureInfo.InvariantCulture)\n\n    let private cache = \n        let today = DateTime.Now\n        let nextMonth = today.AddMonths(1)\n        let eom = DateTime(nextMonth.Year, nextMonth.Month, 1).AddSeconds(-1.0) \n        Runtime.Caching.createInternetFileCache \u0022French\u0022 (eom - today)\n\n    let private getData (dataset:string) =\n        match cache.TryRetrieve(dataset) with\n        | Some data -\u003E data\n        | None -\u003E\n            //let dataset = \u0022F-F_Research_Data_Factors_CSV\u0022\n            let urlString = $\u0022http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/ftp/{dataset}.zip\u0022\n            let request = Http.RequestStream(urlString, httpMethod = \u0022GET\u0022,headers = [HttpRequestHeaders.Accept HttpContentTypes.Any])\n            use archive = new ZipArchive(request.ResponseStream,ZipArchiveMode.Read)\n            let file = archive.GetEntry($\u0022{dataset}\u0022.Replace(\u0022_CSV\u0022,\u0022.CSV\u0022))\n            use reader = new StreamReader(file.Open())\n            let data  = reader.ReadToEnd()\n            cache.Set(dataset,data)\n            data\n    let getFF3 frequency =\n            let (dataset, dateParser) =\n                match frequency with\n                | Monthly -\u003E \u0022F-F_Research_Data_Factors_CSV\u0022, frenchMonth\n                | Daily -\u003E \u0022F-F_Research_Data_Factors_daily_CSV\u0022, frenchDay\n            let data = new StringReader(getData dataset)\n            [| while data.Peek() \u003C\u003E -1 do\n                    data.ReadLine() |]\n            |\u003E Array.skipWhile(fun line -\u003E not (line.Contains(\u0022Mkt-RF\u0022)))\n            |\u003E Array.skip 1\n            |\u003E Array.takeWhile(fun line -\u003E line \u003C\u003E \u0022\u0022)\n            |\u003E Array.map(fun line -\u003E \n                let parsedLine = FF3Csv.ParseRows(line).[0] \n                { Date = dateParser parsedLine.Date\n                  MktRf = float parsedLine.\u0060\u0060Mkt-RF\u0060\u0060 / 100.0\n                  Smb = float parsedLine.SMB / 100.0\n                  Hml = float parsedLine.HML / 100.0\n                  Rf = float parsedLine.RF / 100.0 \n                  Frequency = frequency })\n\n    let getFF5 frequency =\n        let (dataset, dateParser) =\n            match frequency with\n            | Monthly -\u003E \u0022F-F_Research_Data_5_Factors_2x3_CSV\u0022, frenchMonth\n            | Daily -\u003E \u0022F-F_Research_Data_5_Factors_2x3_daily_CSV\u0022, frenchDay\n        let data = new StringReader(getData dataset)\n        [| while data.Peek() \u003C\u003E -1 do\n                data.ReadLine() |]\n        |\u003E Array.skipWhile(fun line -\u003E not (line.Contains(\u0022Mkt-RF\u0022)))\n        |\u003E Array.skip 1\n        |\u003E Array.takeWhile(fun line -\u003E line \u003C\u003E \u0022\u0022)\n        |\u003E Array.map(fun line -\u003E \n            let parsedLine = FF5Csv.ParseRows(line).[0] \n            { Date = dateParser parsedLine.Date\n              MktRf = float parsedLine.\u0060\u0060Mkt-RF\u0060\u0060 / 100.0\n              Smb = float parsedLine.SMB / 100.0\n              Hml = float parsedLine.HML / 100.0\n              Rmw = float parsedLine.RMW / 100.0\n              Cma = float parsedLine.CMA / 100.0\n              Rf = float parsedLine.RF / 100.0 \n              Frequency = frequency })\n\nmodule Fred =\n    type Series = CsvProvider\u003C\u0022https://fred.stlouisfed.org/graph/fredgraph.csv?id=GS10\u0022,\n                              Schema=\u0022Date,Value (float)\u0022,\n                              MissingValues=\u0022.\u0022\u003E\n    let private fredUrl series = $\u0022https://fred.stlouisfed.org/graph/fredgraph.csv?id={series}\u0022\n    \n    ///\u003Csummary\u003EGets a FRED data series as a CsvProvider\u003C/summary\u003E\n        /// \u003Cparam name=\u0022series\u0022\u003EThe series name such as GS10, EXUSEU, etc.\u003C/param\u003E\n    let get (series:string) =  Series.Load(fredUrl series)\n    "},{"uri":"/Teaching/VolatilityTiming.html","title":"Volatility timing\n","content":"(**\n# Volatility timing\nWe\u0027re going to look at how to manage portfolio volatility. Managing volatility is a fundamental risk-management task. You probably have some notion of the amount of volatility that you want in your portfolio, or that you feel comfortable bearing. Maybe you\u0027re ok with an annualized volatility of 15%, but 30% is too much and makes it hard for you to sleep at night. If that\u0027s the case, then when markets get volatile you might want to take action to reduce your portfolio\u0027s volatility. We\u0027ll discuss some strategies for predicting and managing volatility below.\n\nWe will focus on allocating between a risky asset and a risk-free asset as a way to manage volatility (i.e., two-fund seperation). We\u0027re taking the risky asset, such as the market portfolio of equities, as given. The essential idea is to put more weight on the risky asset when expected volatility is low and less weight on the risky asset when expected volatility is high. This is related to a portfolio construction strategy known as risk-parity. The managed volatility strategy that we consider below is based off work by [Barroso and Santa-Clara (2015)](https://scholar.google.com/scholar?hl=en\u0026as_sdt=0%2C39\u0026q=barroso\u002Bsanta-clara\u002B2015\u002Bjfe\u0026btnG=), [Daniel and Moskowitz (2016)](https://scholar.google.com/scholar?hl=en\u0026as_sdt=0%2C39\u0026q=daniel\u002Band\u002Bmoskowitz\u002Bmomentum\u002Bcrash\u002B2016\u002Bjfe\u0026btnG=), and [Moreira and Muir (2017)](https://scholar.google.com/scholar?hl=en\u0026as_sdt=0%2C39\u0026q=moreira\u002Band\u002Bmuir\u002B2017\u002Bjf\u002Bvolatility\u002Bmanaged\u002Bportfolios\u0026btnG=). The Moreira and Muir (2017) paper is probably the best place to start. Though the observation that a) predictable volatility and b) unpredictable returns implies predictable Sharpe ratios predates the aoove work.\n*)\n\n(**\n## Acquiring Fama-French data\nAs a start, let\u0027s acquire a long daily time series on aggregate US market returns. We\u0027ll use the 3 factors [dataset](http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/Data_Library/f-f_factors.html).\n\n*)\n\n#r \u0022nuget: FSharp.Data\u0022\n#load \u0022Common.fsx\u0022\nopen System\nopen FSharp.Data\nopen Common\n\nlet ff3 = French.getFF3 Frequency.Daily\n        \n\nfsi.AddPrinter\u003CDateTime\u003E(fun dt -\u003E dt.ToString(\u0022s\u0022))\n\nff3 |\u003E Seq.take 5\n\n(**\n## Observing time-varying volatility\nOne thing that can help us manage volatility is the fact that volatility tends to be somewhat persistent. By this we mean that if our risky asset is volatile today, then it is likely to be volatile tomorrow. We can observe this by plotting monthly volatility as we do below. It also means that we can use past volatility to form estimates of future volatility.\n*)\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n#r \u0022nuget: Plotly.NET, 2.0.0-beta5\u0022\nopen FSharp.Stats\nopen Plotly.NET\n\n\nlet annualizeDaily x = x * sqrt(252.0) * 100. \n\nlet monthlyVol =\n    ff3\n    |\u003E Seq.sortBy(fun x -\u003E x.Date)\n    |\u003E Seq.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n    |\u003E Seq.map(fun (_ym, xs) -\u003E \n        let dt = xs |\u003E Seq.last |\u003E fun x -\u003E x.Date\n        let annualizedVolPct = xs |\u003E stDevBy(fun x -\u003E x.MktRf) |\u003E annualizeDaily\n        dt, annualizedVolPct)\n    |\u003E Seq.toArray\n\nlet volChart vols =\n    let getYear f = vols |\u003E Seq.map(fun (dt:DateTime,_vol) -\u003E dt.Year ) |\u003E f \n    let minYear = getYear Seq.min\n    let maxYear = getYear Seq.max\n    vols\n    |\u003E Chart.Column    \n    |\u003E Chart.withX_AxisStyle(title = $\u0022Time-varying Volatility ({minYear}-{maxYear})\u0022)\n    |\u003E Chart.withY_AxisStyle(title = \u0022Annualized Volatility (%)\u0022)\n\nlet allVolsChart = volChart monthlyVol\nlet since2019VolChart = \n    monthlyVol \n    |\u003E Seq.filter(fun (dt,_) -\u003E dt \u003E= DateTime(2019,1,1))\n    |\u003E volChart\n\n(***do-not-eval***)\nallVolsChart |\u003E Chart.Show\nsince2019VolChart |\u003E Chart.Show\n\n(***hide***)\nallVolsChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n(***hide***)\nsince2019VolChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***)\n\n(**\n## Review of calculating portfolio weights\nWe are going to look at various portfolios, so it is good to review portfolio weights.\n\n- Portfolio weight is $(\\text{position value})/(\\text{portfolio value})$. \n- A long portfolio has portfolio weights that sum to 1.0 (or 100%). \n- A zero-cost portfolio has portfolio weights that sum to 0.0.\n*)\n\ntype Position = { Id: string; Position: int; Price : decimal }\n\nlet portfolio =\n    [| { Id = \u0022AAPL\u0022; Position = 100; Price = 22.20m }\n       { Id = \u0022AMZN\u0022; Position = 20; Price = 40.75m }\n       { Id = \u0022TSLA\u0022; Position = 50; Price = 30.6m } |]\n\n// We can do it on the fly\nportfolio\n|\u003E Array.map(fun pos -\u003E // getting position value\n       pos.Id,\n       (float pos.Position)*(float pos.Price))\n|\u003E fun ps -\u003E // calculating weights\n    let portfolioValue = \n        ps \n        |\u003E Array.sumBy(fun (id, value) -\u003E value)\n    ps\n    |\u003E Array.map(fun (id, value) -\u003E id, value / portfolioValue)\n\n\n// We can also define a bit more structure to get the same thing.\n// Proper functions with defined types are good for reusable code.\ntype PositionValue = { Id : string; Value : float }\ntype PositionWeight = { Id : string; Weight : float }\n\nlet calcValue (x:Position) = \n    { Id = x.Id\n      Value = (float x.Position) * (float x.Price)}\n\nlet calcWeights xs =\n    let portfolioValue = xs |\u003E Array.sumBy(fun x -\u003E x.Value)\n    xs\n    |\u003E Array.map(fun pos -\u003E \n        { Id = pos.Id\n          Weight = pos.Value / portfolioValue })\n\nportfolio\n|\u003E Array.map calcValue\n|\u003E calcWeights\n\nlet portfolioWithShorts =\n    [| { Id = \u0022AAPL\u0022; Position = 100; Price = 22.20m }\n       { Id = \u0022AMZN\u0022; Position = -20; Price = 40.75m }\n       { Id = \u0022TSLA\u0022; Position = 50; Price = 30.6m } |]\n\nportfolioWithShorts\n|\u003E Array.map calcValue\n|\u003E calcWeights\n\n(**\n## Effect of leverage on volatility\nRecall the formula for variance of a portfolio consisting of stocks $x$ and $y$:\n\n$$ \\sigma^2 = w_x^2 \\sigma^2_x \u002B w_y^2 \\sigma^2_y \u002B 2 w_x w_y cov(r_x,r_y), $$\n\nwhere $w_x$ and $w_y$ are the weights in stocks $x$ and $y$, $r_x$ and $r_y$ are the stock returns, $\\sigma^2$ is variance, and $cov(.,.)$ is covariance. \n\nIf one asset is the risk free asset (borrowing a risk-free bond), then this asset has no variance and the covariance term is 0.0. Thus we are left with the result that if we leverage asset $x$ by borrowing or lending the risk-free asset, then our leveraged portfolio\u0027s standard deviation ($\\sigma$) is\n\n$$ \\sigma^2 = w_x^2 \\sigma^2_x \\rightarrow \\sigma = w_x \\sigma_x$$ \n*)\n\nlet leveragedVol (weight, vol) = weight * vol\n\n/// We\u0027re doing leverage in terms of weigh on the risky asset.\n/// 1 = 100%, 1.25 = 125%, etc.\nlet exampleLeverages =\n    [ 1.0; 1.5; 2.0 ]\n\nlet rollingVolSubset =\n    monthlyVol\n    |\u003E Seq.filter(fun (dt, vol) -\u003E dt \u003E DateTime(2020,1,1))\n\n// Let\u0027s take each of the leverages and map a function to them.\n// The function takes a leverage as input, and the output is\n// a tuple of (leverage, leveraged volatilities)\nlet exampleLeveragedVols =\n    exampleLeverages\n    |\u003E Seq.map(fun leverage -\u003E\n        let leveragedVols =\n            rollingVolSubset\n            |\u003E Seq.map(fun (dt, vol) -\u003E \n                dt, leveragedVol(leverage, vol))\n        leverage, leveragedVols)\n\nlet exampleLeveragesChart =\n    exampleLeveragedVols\n    |\u003E Seq.map(fun (leverage, leveragedVols) -\u003E\n        leveragedVols\n        |\u003E Chart.Line\n        |\u003E Chart.withTraceName $\u0022Levarage of {leverage}\u0022)\n    |\u003E Chart.Combine\n\n(***do-not-eval***)\nexampleLeveragesChart |\u003E Chart.Show\n\n(***hide***)\nexampleLeveragesChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Effect of leverage on returns\nThe effect of leverage on returns can be seen from the portfolio return equation,\n$$ r_p = \\Sigma^N_{i=1} w_i r_i,$$\nwhere $r$ is return, $i$ indexes stocks, and $w$ is portfolio weights.\n\nSo if we borrow 50% of our starting equity by getting a risk-free loan, then we have\n$$ r_{\\text{levered}} = 150\\% \\times r_{\\text{unlevevered}} - 50\\% \\times r_f$$\n\nIf we put in terms of excess returns,\n$$ r_{\\text{levered}} - r_f = 150\\% \\times (r_{\\text{unlevevered}}-r_f) - 50\\% \\times (r_f-r_f)=150\\% \\times (r_{\\text{unlevevered}}-r_f)$$\n\nSo, if we work in excess returns we can just multiply unlevered excess returns by the weight. \n\nDoes this check out? Imagine that you have \\$1 and you borrow \\$1 for a net stake of \\$2. Then you invest at an exess return of 15%. What are you left with?\n*)\n\nlet invest = 1.0m\nlet borrow = 1.0m \nlet ret = 0.15m\nlet result = (invest \u002B borrow)*(1.0m\u002Bret)-borrow\nresult = 1.0m \u002B ret * (invest \u002B borrow)/invest\n\nlet leveredReturn leverage (x : French.FF3Obs ) = leverage * x.MktRf\n\n\n(**\n## Calculating cumulative returns\nWe can illustrate this with cumulative return plots. Let\u0027s first show a simple example for how we can calculate cumulative returns.\n\nImagine that you invest \\$1 at a 10% return. What do you have after n years?\n*)\n\n[| 1.0 .. 5.0 |]\n|\u003E Array.map(fun years -\u003E 1.0*(1.1**years))\n\n(** But what if we have the data like this?*)\n[| for i = 1 to 5 do 0.1 |]\n\n(** For this, we could use functions that operate by threading an accumulator through a collection: [fold](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-arraymodule.html#fold) and [scan](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-arraymodule.html#scan). The website [www.fsharpforfunandprofit.com](https://fsharpforfunandprofit.com/posts/list-module-functions/#14) has a good discussion of the various module functions. We could use \u0060fold\u0060 to return a final cumulative return or \u0060scan\u0060 to return intermediate and final cumulative returns.\n\nLet\u0027s start with \u0060scan\u0060 to see how it works. First, let\u0027s define a function to calculate returns:\n*)\n\n/// \u003Csummary\u003EFunction to calculate cumulative returns.\n/// We are using the FV = PV*(1\u002Br) formula.\u003C/summary\u003E\n/// \u003Cparam name=\u0022pv\u0022\u003Ecumulative return thus far, like the PV in our FV formula\u003C/param\u003E\n/// \u003Cparam name=\u0022ret\u0022\u003Ethis period\u0027s return\u003C/param\u003E \nlet fv pv ret = pv*(1.0\u002Bret)\n\n// Now let\u0027s imagine we have a series of returns like\n[0.1; -0.05; 0.3; -0.15]\n\n// Our starting place is 1.0\n1.0\n(*** include-it ***)\n// After the first period we\u0027re at\n(fv 1.0 0.1)\n(*** include-it ***)\n// After two periods we\u0027re at\n(fv (fv 1.0 0.1) -0.05)\n(*** include-it ***)\n// And so on\n(fv (fv (fv 1.0 0.1) -0.05) 0.3)\n(*** include-it ***)\n(fv (fv (fv (fv 1.0 0.1) -0.05) 0.3) -0.15)\n(*** include-it ***)\n\n// now put these all in a list\n[(fv 1.0 0.1)\n (fv (fv 1.0 0.1) -0.05)\n (fv (fv (fv 1.0 0.1) -0.05) 0.3)\n (fv (fv (fv (fv 1.0 0.1) -0.05) 0.3) -0.15)]\n(*** include-it ***)\n\n(*\nWe can do this all in one step using scan. Scan expects: to be given:\n\n- An initial state (\u00601.0\u0060).\n- A collection to accumulate (\u0027[...]\u0060).\n- A function to apply to do the accumulation (\u0060fv\u0060). The function nee\n*)\n(1.0, [0.1; -0.05; 0.3; -0.15])\n||\u003E List.scan fv\n(*** include-it ***)\n\n// Or if all we cared about was the final cumulative sum,\n// we could just use fold\n(1.0, [0.1; -0.05; 0.3; -0.15])\n||\u003E List.fold fv\n(*** include-it ***)\n\n(** One thing about \u0060scan\u0060 and \u0060fold\u0060 is that they expect the output of our function \u0060fv\u0060 to have the same F# type as\nthe accumulator (in this case our pv term, but often called acc in functions). This is fine if we\u0027re\njust working with floats. But sometimes we want to thread a float accumulator through our function but return a different \u0060type\u0060 from our function. This is where \u0060mapFold\u0060 is useful. It combines a \u0060map\u0060 function and a \u0060fold\u0060 function.\n\nIf we look at the definition of \u0060mapFold\u0060 for arrays, we can see that we call it with \u0060Array.mapFold mapping state array\u0060, where \n\n\n\u0060\u0060\u0060output\nmapping : \u0027State -\u003E \u0027T -\u003E \u0027Result * \u0027State\nThe function to transform elements from the input array and accumulate the final value.\n\nstate : \u0027State\nThe initial state.\n\narray : \u0027T[]\nThe input array.\n\nReturns: \u0027Result[] * \u0027State\nThe array of transformed elements, and the final accumulated value.\n\u0060\u0060\u0060\n\nBut maybe it\u0027s easier to just think of it as a combination of a \u0060map\u0060 transformation and a \u0060fold\u0060 transformation.\n\nIn this example, we want to thread a float accumulator through a collection, but we\u0027re interested in returning a record with a stock ticker symbol and the cumulative return of the stock at that point.\n*)\n\n\ntype MapFoldInputRecord = { Symbol: string; Return : float }\ntype MapFoldOutputRecord = { Symbol : string; CumulativeReturn : float }\n\n// \u0060map\u0060 transformation\nlet mapfun pv (input:MapFoldInputRecord) =\n  let cumulativeReturn = pv*(1.0 \u002B input.Return)\n  { Symbol = input.Symbol; CumulativeReturn = cumulativeReturn }\n\nmapfun 10.0 { Symbol = \u0022AAPL\u0022; Return = 0.3 }\n(*** include-it ***)\n\n// \u0060fold\u0060 transformation\nlet foldfun pv (input:MapFoldInputRecord) =\n  pv*(1.0 \u002B input.Return)\n\nfoldfun 10.0 { Symbol = \u0022AAPL\u0022; Return = 0.3 }\n(*** include-it ***)\n\n(** \nNow we\u0027ll combine the \u0060map\u0060 and \u0060fold\u0060 transformations.\n\nmapFold expects us to give it a function that operates on an accumulator\nand the collection element. It expect us to return a tuple of the \u0060map\u0060 result\nand the \u0060fold\u0060 result.\n\nSo let\u0027s create \u0060mapfoldfun\u0060 that is a tuple of the \u0060mapfun\u0060 and \u0060foldfun\u0060 transformations.\n*)\nlet mapfoldfun acc input = mapfun acc input, foldfun acc input\n\nmapfoldfun 10.0 { Symbol = \u0022AAPL\u0022; Return = 0.3 }\n(*** include-it ***)\n\n// Now create a list of records that we want to get cumulative returns for\nlet mapFoldExampleRecords =\n    [{ Symbol = \u0022AAPL\u0022; Return = 0.1}\n     { Symbol = \u0022AAPL\u0022; Return = -0.05}\n     { Symbol = \u0022AAPL\u0022; Return = 0.3}\n     { Symbol = \u0022AAPL\u0022; Return = -0.15}]\n\n// Now accumulate them with mapFold and our mapfoldfun.\n// This will give us a tuple of cumulative returns as records of type \u0060MapFoldOutputRecord\u0060 and the final cumulative return.\n(1.0, mapFoldExampleRecords)\n||\u003E List.mapFold mapfoldfun\n(*** include-it ***)\n\n// We can discard the final cumulative return part by calling fst at the end.\n(1.0, mapFoldExampleRecords)\n||\u003E List.mapFold mapfoldfun\n|\u003E fst\n(*** include-it ***)\nList.scan (fun acc x -\u003E {x with Return = (1.0\u002Bacc.Return) * (1.0\u002Bx.Return)-1.0}) mapFoldExampleRecords.Head mapFoldExampleRecords.Tail\n// Same thing, but using an anonymous function instead of mapfoldfun\n(1.0, mapFoldExampleRecords)\n||\u003E List.mapFold(fun acc input -\u003E \n    let cumret = acc*(1.0\u002Binput.Return)\n    { Symbol = input.Symbol; CumulativeReturn = cumret}, cumret)\n|\u003E fst\n\n(** Now we know how to calculate cumulative returns on our real data.*)\n\nlet since2020 = \n    ff3 |\u003E Seq.filter(fun x -\u003E x.Date \u003E= DateTime(2020,1,1))\n    \nlet cumulativeReturnEx =\n    let mapping inCumRet (x: French.FF3Obs) = \n        let outCumRet = inCumRet * (1.0 \u002B x.MktRf)\n        { x with MktRf = outCumRet - 1.0}, outCumRet\n    \n    (1.0, since2020)\n    ||\u003E Seq.mapFold mapping \n    |\u003E fst\n\nlet cumulativeReturnExPlot =\n    cumulativeReturnEx\n    |\u003E Seq.map(fun x -\u003E x.Date.Date, x.MktRf)\n    |\u003E Chart.Line\n\n(***do-not-eval***)\ncumulativeReturnExPlot |\u003E Chart.Show\n\n(***hide***)\ncumulativeReturnExPlot |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(** Let\u0027s try leverage with daily rebalancing (each day we take leverage of X).*)\n\nlet getLeveragedReturn leverage =\n    let mapping inCumRet x = \n        let lr = leveredReturn leverage x\n        let outCumRet = inCumRet * (1.0 \u002B lr)\n        { x with MktRf = outCumRet - 1.0}, outCumRet\n    \n    (1.0, since2020)\n    ||\u003E Seq.mapFold mapping \n    |\u003E fst\n    |\u003E Seq.map(fun x -\u003E x.Date.Date, x.MktRf)\n\nlet exampleLeveragedReturnChart = \n    exampleLeverages\n    |\u003E Seq.map(fun lev -\u003E\n        getLeveragedReturn lev\n        |\u003E Chart.Line\n        |\u003E Chart.withTraceName $\u0022Leverage of {lev}\u0022) \n    |\u003E Chart.Combine\n\n(***do-not-eval***)\nexampleLeveragedReturnChart |\u003E Chart.Show\n\n(***hide***)\nexampleLeveragedReturnChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n(**\n## Predicting volatility\nTo manage or target volatility, we need to be able to predict volatility. A simple model would be to use past volatility to predict future volatility. How well does this work?\n\nLet\u0027s start by creating a dataset that has the past 22 days as a training period and the 23rd day as a test period. We\u0027ll look at how volatility the past 22 days predicts volatility on the 23rd day.\n*)\n\nlet dayWithTrailing =\n    ff3 \n    |\u003E Seq.sortBy(fun x -\u003E x.Date)\n    |\u003E Seq.windowed 23\n    |\u003E Seq.map(fun xs -\u003E\n        let train = xs |\u003E Array.take (xs.Length-1)\n        let test = xs |\u003E Array.last\n        train, test)\n\n(*\nOne way to do this is to look at the correlation between volatilities. What is the correlation between volatility the past 22 days (training observations) and volatility on the 23rd day (test observation)? \n\nHow do we measure volatility that last (23rd) day? You can\u0027t calculate a standard deviation of returns when there is one day. You need multiple days. But we can create a pseudo 1-day standard deviation by using the absolute value of the return that last day. \n*)\n\nopen Correlation\n\nlet trainVsTest =\n    dayWithTrailing\n    |\u003E Seq.map(fun (train, test) -\u003E\n        let trainSd = train |\u003E Seq.stDevBy(fun x -\u003E x.MktRf)\n        let testSd = abs(test.MktRf)\n        annualizeDaily trainSd, annualizeDaily testSd)\n\n\n// Plot a sample of 1_000 points\nlet trainVsTestChart =\n    trainVsTest\n    |\u003E Seq.splitInto 1_000 // 1000 groups of train, test\n    |\u003E Seq.map Seq.head // get the observation at the start of each group\n    |\u003E Chart.Point\n   \n\n(***do-not-eval***)\ntrainVsTestChart |\u003E Chart.Show\n\n(***hide***)\ntrainVsTestChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\nlet trainPdSd, testPdSd = trainVsTest |\u003E Seq.unzip\nSeq.pearson trainPdSd testPdSd\n\n(*** include-it ***)\n\n(*\nAnother way is to try sorting days into 5 groups based on trailing 22-day volatility. \nThen we\u0027ll see if this sorts actual realized volatility. Think of this as splitting the points in the above chart into 5 groups along the x-axis and comparing the typical x-axis value to the typical y-axis value.\n*)\n\ndayWithTrailing\n|\u003E Seq.sortBy(fun (train, _test) -\u003E train |\u003E stDevBy(fun x -\u003E x.MktRf))\n|\u003E Seq.splitInto 5\n|\u003E Seq.iter(fun xs -\u003E\n    \n    let predicted = \n        xs \n        |\u003E Array.collect fst\n        |\u003E stDevBy (fun x -\u003E x.MktRf)\n        |\u003E annualizeDaily\n    let actual = \n        xs \n        |\u003E Array.map(fun (_train, test) -\u003E test.MktRf)\n        |\u003E stDev \n        |\u003E annualizeDaily\n    printfn $\u0022N: {xs.Length}, Predicted: %.1f{predicted}, Actual: %.1f{actual}\u0022)\n\n(***include-output***)\n\n(** Even with this very simple volatility model, we seem to do a reasonable job predicting volatility. We get a decent spread.*)\n\n(**\n## Targetting volatility\nHow can we target volatility? Recall our formula for a portfolio\u0027s standard deviation if we\u0027re allocating between the risk-free asset and a risky asset:\n$$\\sigma = w_x \\sigma_x$$ \nIf we choose \n$$w_x=\\frac{\\text{target volatility}}{\\text{predicted volatility}}=\\frac{\\text{target}}{\\hat{\\sigma}_x}$$ \nthen we get\n$$\\sigma = \\frac{\\text{target}\\times \\sigma_x}{\\hat{\\sigma}_x}$$ \n\nWe\u0027re not going to predict volatility perfectly, but *if* we did then we\u0027d have a portfolio that had a constant volatility equal to our target.\n\nLet\u0027s see what happens if we try to target 15% annualized volatility.\n*)\n\ntype VolPosition =\n    { Date : DateTime \n      Return : float \n      Weight : float }\n\nlet targetted =\n    dayWithTrailing\n    |\u003E Seq.map(fun (train,test) -\u003E \n        let predicted = train |\u003E stDevBy(fun x -\u003E x.MktRf) |\u003E annualizeDaily\n        let w = (15.0/predicted)\n        { Date = test.Date\n          Return = test.MktRf * w \n          Weight = w })\n\nlet targettedSince2019 = \n    targetted\n    |\u003E Seq.filter(fun x -\u003E x.Date \u003E= DateTime(2019,1,1) )\n    |\u003E Seq.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n    |\u003E Seq.map(fun (_, xs) -\u003E \n        xs |\u003E Seq.map(fun x -\u003E x.Date) |\u003E Seq.max,\n        xs |\u003E stDevBy(fun x -\u003E x.Return) |\u003E annualizeDaily) \n    |\u003E volChart\n    |\u003E Chart.withTraceName \u0022Managed\u0022\n\nlet rawSince2019 =\n    monthlyVol\n    |\u003E Seq.filter(fun (dt,_) -\u003E dt \u003E= DateTime(2019,1,1))\n    |\u003E volChart\n    |\u003E Chart.withTraceName \u0022Unmangaged\u0022\n\nlet weightsSince2019 = \n    targetted\n    |\u003E Seq.filter(fun x -\u003E x.Date \u003E= DateTime(2019,1,1) )\n    |\u003E Seq.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n    |\u003E Seq.map(fun (_, xs) -\u003E \n        xs |\u003E Seq.map(fun x -\u003E x.Date) |\u003E Seq.max,\n        xs |\u003E Seq.averageBy(fun x -\u003E x.Weight))\n    |\u003E Chart.Line \n    |\u003E Chart.withTraceName \u0022weight on the Market\u0022\n\nlet volComparison = \n    [ targettedSince2019; rawSince2019]\n    |\u003E Chart.Combine\n\nlet volComparisonWithWeights =\n    Chart.Grid([[volComparison]\n                [weightsSince2019 ]],\n                sharedAxes = true)\n\n\n(***do-not-eval***)\nvolComparisonWithWeights |\u003E Chart.Show\n\n(***hide***)\nvolComparisonWithWeights |\u003E GenericChart.toChartHTML\n(***include-it-raw***) \n\n(** We can see that in this example, \n\n- Volatility still moves around with our managed portfolio. We haven\u0027t targetted a 15\\% volatility perfectly. \n- We do avoid some of the extreme volatilities from 2020, particularly in March and April.\n- The weight we put on the market varies quite (implies lots of trading) and goes as high as 2 (lots of leverage). *)\n\n(**\n## Evaluating performance.\n\nLet\u0027s now compare buy and hold to our managed volatility strategy. \n\nFor the managed portfolio, we\u0027ll also impose the constraint that the investor cannot borrow more than 30% of their equity (i.e, max weight = 1.3).\n\nWe start by defining functions to calculate the weights. In the managed weights, we set the numerator so that we\u0027re targetting the full-sample standard deviation of the market.\n*)\n\nlet leverageLimit = 1.3\n\nlet sampleStdDev = \n    dayWithTrailing \n    |\u003E Seq.stDevBy(fun (train, test) -\u003E test.MktRf)\n    |\u003E annualizeDaily\n\nlet buyHoldWeight predictedStdDev = 1.0\n\nlet inverseStdDevWeight predictedStdDev = \n    min (sampleStdDev / predictedStdDev) leverageLimit\n\nlet inverseStdDevNoLeverageLimit predictedStdDev = \n    sampleStdDev / predictedStdDev\n\n\nlet getManaged weightFun =\n    dayWithTrailing\n    |\u003E Seq.map(fun (train,test) -\u003E \n        let predicted = train |\u003E stDevBy(fun x -\u003E x.MktRf) |\u003E annualizeDaily\n        let w = weightFun predicted\n        { Date = test.Date\n          Return = test.MktRf * w \n          Weight = w })\n    |\u003E fun xs -\u003E // Rescale to have same realized SD for\n                 // more interpretable graphs. \n                 // Does not affect sharpe ratio\n        let sd = xs |\u003E stDevBy(fun x -\u003E x.Return) |\u003E annualizeDaily\n        xs |\u003E Seq.map(fun x -\u003E { x with Return = x.Return * (sampleStdDev/sd)})\n\nlet accVolPortReturn (port: seq\u003CVolPosition\u003E) =\n    let mapper acc (x : VolPosition) =\n        let outAcc = acc * (1.0\u002Bx.Return)\n        { x with Return = outAcc }, outAcc\n    (1.0, port)\n    ||\u003E Seq.mapFold mapper \n    |\u003E fst\n\nlet portChart name port  = \n    port \n    |\u003E Seq.map(fun x -\u003E x.Date, x.Return)\n    |\u003E Chart.Line\n    |\u003E Chart.withTraceName name\n    |\u003E Chart.withY_Axis (Axis.LinearAxis.init(AxisType = StyleParam.AxisType.Log))\n\n    \nlet buyHoldMktPort = getManaged buyHoldWeight \nlet managedMktPort = getManaged inverseStdDevWeight\nlet managedMktPortNoLimit = getManaged inverseStdDevNoLeverageLimit \n\nlet bhVsManagedChart =\n    Chart.Combine(\n        [ buyHoldMktPort |\u003E accVolPortReturn |\u003E (portChart \u0022Buy-Hold\u0022)\n          managedMktPort |\u003E accVolPortReturn |\u003E (portChart \u0022Managed Vol\u0022)\n          managedMktPortNoLimit |\u003E accVolPortReturn |\u003E (portChart \u0022Managed Vol No Limit\u0022)\n          ])\n\n(***do-not-eval***)\nbhVsManagedChart |\u003E Chart.Show\n\n(***hide***)\nbhVsManagedChart |\u003E GenericChart.toChartHTML\n(***include-it-raw***)\n\n[ buyHoldMktPort, \u0022Buy-Hold Mkt\u0022\n  managedMktPort, \u0022Managed Vol Mkt\u0022\n  managedMktPortNoLimit, \u0022Manage Vol No Limit\u0022]\n|\u003E Seq.iter(fun (x, name) -\u003E \n    let mu = \n        x \n        |\u003E Seq.averageBy(fun x -\u003E x.Return) \n        |\u003E fun x -\u003E round 2 (100.0*252.0*x)\n    let sd = x |\u003E Seq.stDevBy(fun x -\u003E x.Return) |\u003E annualizeDaily\n    printfn $\u0022Name: %25s{name} Mean: %.2f{mu} SD: %.2f{sd} Sharpe: %.3f{round 3 (mu/sd)}\u0022)\n(***include-output***)\n\n(**\n## Things to consider\n\n- What\u0027s a reasonable level of volatility to target?\n- What\u0027s a reasonable level of leverage, and what should we think about when leveraging a portfolio that has low recent volatility?\n- What happens if expected returns go up when volatility is high?\n- How do we decide on what risky portfolio to invest in?\n*)\n\n              "},{"uri":"/Teaching/index.html","title":"Teaching\n","content":"# Teaching"},{"uri":"/Teaching/fundamentals.html","title":"Fundamentals\n","content":"(*** hide ***)\n/// example fast binder url: https://mybinder.org/v2/gh/fsprojects/fsharp.formatting/master?urlpath=git-pull?repo=https:/nhirschey.github.com/teaching/gh-pages/fundamentals.ipynb\n\n(**\n\n[![Binder](images/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](images/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](images/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n\n\n# Fundamentals\nA good place to start is to define a one-period return calculation.\n\nObjectives:\n\n- [Interactive programming](#Interactive-programming)\n- [How to calculate returns](#Calculating-returns).\n- [Working with data.](#Working-with-data)\n- [How to calculate return volatility](#Volatility)\n*)\n\n(**\n## Interactive programming\n\nWe are going to focus on interactive programming. This is the most productive (and most common) type of analytic programming. In constrast to compiled programs (e.g, C, C\u002B\u002B, Fortran, Java), interactive programs:\n\n- Allow rapid iterative development.\n- You can quickly quickly write and rewrite sections of code, evaluating the output, without having to rerun the entire program.\n- This is especially useful for financial analysis, because we often evaluate large datasets that take a long time to process.\n\nInteractive programming typically involves a [REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop) (Read, Evaluate, Print, Loop). It is common for scripting langauges such as R, Python, Julia, Ruby, and Perl.\n\n### The terminal\n\nThe most basic way that you can run interactive code is at the command line using an interpreter. We can star the F# interactive interpreter by opening a terminal (e.g., terminal.app, cmd, powershell) and running \u0060dotnet fsi\u0060.\n\nOnce fsi is open, we can type a code snippet in the prompt followed by \u0022;;\u0022 to terminate it and it will run.\n\n![fsi](images/fsi.png)\n\n\nIt is fine to run code this way, but we can do better using an IDE (Integrated development environment) that incorportes syntax highlighting, intellisense tooltips, and execution.\n*)\n\n\n(**\n## Calculating returns\n\n### Basic calculations in fsi\n\nLet\u0027s assume that you have \\$120.00 today and that you had \\$100.00 a year ago. Your annual return is then:\n\n*)\n\n(120.0 / 100.0) - 1.0\n\n(*** include-fsi-output ***)\n\n(**\n### Basic numerical types: float, int, and decimal\n\nNotice that I included zeros after the decimal point. This is important. The decimal point makes it a [floating point](https://en.wikipedia.org/wiki/Floating-point_arithmetic) number. Floating point numbers (floats) are the most commonly used numerical type for mathematical calculations. \n\nIf we left the decimal off it would be an integer and we would get the wrong answer because integers cannot represent fractions.\n*)\n\n(120/100) - 1\n\n(*** include-fsi-output ***)\n\n(** The other numerical data type is [decimal](https://en.wikipedia.org/wiki/Decimal_data_type). *)\n\n(120m/100m) - 1m\n\n(*** include-fsi-output ***)\n\n(** Decimals are used when you need an exact fractional amount. Floats are insufficient in these circumstances because *\u0022... such representations typically restrict the denominator to a power of two ... 0.3 (3/10) might be represented as 5404319552844595/18014398509481984 (0.299999999999999988897769...)\u0022* ([see wiki](https://en.wikipedia.org/wiki/Decimal_data_type)).\n\n### Static type checking\n\nFinally, since F# is staticly typed, we must do arithmetic using numbers that are all the same type. If we mix floats and integers we will get an error:\n\n\u0060\u0060\u0060fsharp\n(120.0 / 100) - 1.0\n\u0060\u0060\u0060\n\u0060\u0060\u0060output\nfundamentals.fsx(18,10): error FS0001: The type \u0027int\u0027 does not match the type \u0027float\u0027\n\u0060\u0060\u0060\nStatic tying can slow you down a bit writing simple small programs, but as programs get larger and more complex the benefits become apparent. Specifically, static typing as implemented by F#:\n\n- helps you ensure that the code is correct (i.e., the type of the input data matches what the function expects). In the words of Yaron Minksy at Janestreet, you can [\u0022make illegal states unrepresentable\u0022](https://blog.janestreet.com/effective-ml-revisited/) (see [here](https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/) for F# examples).\n- it also facilitates editor tooling that can check your code without running it and give tooltip errors (you should have seen a tooltip error in your editor if you type \u0060(120.0 / 100) - 1.0\u0060 in your program file). It\u0027s like clippy on steriods (you are too young, but your parents might get this reference).\n\n![clippy](images/intellisense-example.png)\n\n[Image source](https://blog.codinghorror.com/it-looks-like-youre-writing-a-for-loop/)\n\n *)\n\n(**\n### Assigning values\nWe could also do the same calculations by assigning \\$120.00 and \\$100.0 to named values.\n*)\n\nlet yearAgo = 100.0\nlet today = 120.0\n(today / yearAgo) - 1.0\n\n(*** include-fsi-output ***)\n(** This works for one-off calculations, but if we want to do this more than once, then it makes more sense to define a function to do this calculation. *)\n\n(**\n### Defining functions \nFunctions map (or transform) inputs into outputs.\n*)\n\n// Here is a simple function.\n// It takes an input as an input x and then it adds\n// 1 to whatever x is.\nlet f(x) = x \u002B 1\n\nf(1) // here x is 1\nf(2) // here x is 2\nf(3) // here x is 3\n\n// We can also chain them\nf(f(f(1))) // = (1 \u002B (1 \u002B (1 \u002B 1)))\n\n// The parentheses are optional, and it\u0027s more standard leave them off.\nlet f2 x = x \u002B 1\n\n// We can easily define a function to calcuate this return. \nlet calcReturn pv fv = (fv / pv) - 1.0\n\n(** The type signature tells us that \u0060calcReturn\u0060 is a function with two float inputs (pv and fv) and it maps those two inputs into a float output. The program was able to infer that \u0060pv\u0060 and \u0060fv\u0060 are floats because of the \u00601.0\u0060 float in the calculation.*)\n\n(** Se can execute it on simple floats:*)\n// here pv = 100., fv = 110.0\ncalcReturn 100.0 110.0\n(*** include-fsi-output ***)\n\n// here pv = 80.0, fv = 60.0\ncalcReturn 80.0 60.0\n\n(*** include-fsi-output ***)\n\n(** Or we can execute it on our previously defined \u0060yearAgo\u0060 and \u0060today\u0060 values: *)\ncalcReturn yearAgo today\n(*** include-fsi-output ***)\n\n(** However, if we try to get it to execute on decimals, we will get an error because we defined the function to only operate on floats. This is another (simple) example of the compiler using type checking.\n\n\u0060\u0060\u0060\ncalcReturn 100.0m 120.0m\n\u0060\u0060\u0060\n\u0060\u0060\u0060output\nfundamentals.fsx(23,14): error FS0001: This expression was expected to have type\n    \u0027float\u0027    \nbut here has type\n    \u0027decimal\u0027    \n\u0060\u0060\u0060\n\n*)\n\n(**\n### Handling dividends\nOur prior return calculation did not handle cash distributions such as dividends. We can incorporate dividends with a small modificaton:\n\n*)\n\nlet simpleReturn beginningPrice endingPrice dividend =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (endingPrice \u002B dividend) / beginningPrice - 1.0\n\n(**\nThe examples thus far have used simple (per period) compounding. We can also calculate continuously compounded returns, sldo known as log returns.\n*)\n\nlet logReturn beginningPrice endingPrice dividend =\n    // This is solving for \u0060r\u0060 in FV = PV*e^(rt) where t=1.\n    log(endingPrice \u002B dividend) - log(beginningPrice)\n\n(** These two calculations give slightly different returns.*)\n\nsimpleReturn 100.0 110.0 0.0 \n(*** include-fsi-output ***)\nlogReturn 100.0 110.0 0.0\n(*** include-fsi-output ***)\n\n(** It is typically not important which version of return you use so long as you are consistent and keep track of what type of return it is when you\u0027re compounding things.\n\n**Practice:** Can you write a function to compound an initial investment of \\$100.00 at 6% for 5 years? You can calculate power and exponents using:*)\n\n2.0**3.0\n(*** include-fsi-output ***)\nlog 2.0\n(*** include-fsi-output ***)\nexp 0.6931\n(*** include-fsi-output ***)\nexp(log(2.0))\n(*** include-fsi-output ***)\n\n(**\n### Tuples \nLooking at our return functions, we\u0027re starting to get several values that we\u0027re passing into the functions individaully. It can be useful to group these values together to make it easy to pass them around. Tuples are a simple way to group values.\n\n*)\n\n(1,2)\n(*** include-fsi-output ***)\n(1,2,3)\n(*** include-fsi-output ***)\n(** Tubles can contain mixed types.*)\n(1,\u00222\u0022)\n(*** include-fsi-output ***)\n(** We can also deconstruct tuples. We can use built-in convenience functions for pairs.*)\nfst (1,2)\n(*** include-fsi-output ***)\nsnd (1,2)\n(*** include-fsi-output ***)\n(** We can also deconstruct tuples using pattern matching.*)\nlet (a, b) = (1, 2)\n(*** include-fsi-output ***)\nlet (c, d, e) = (1, \u00222\u0022, 3.0)\n(*** include-fsi-output ***)\n\n(** Now redefining our simple return function to take a single tuple as the input parameter.*)\n\nlet simpleReturnTuple (beginningPrice, endingPrice, dividend) =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (endingPrice \u002B dividend) / beginningPrice - 1.0\n\nsimpleReturnTuple (100.0, 110.0, 0.0)\n(*** include-fsi-output ***)\nlet xx = (100.0, 110.0, 0.0)\nsimpleReturnTuple xx\n(*** include-fsi-output ***)\n\n(**\n### Records\nIf we want more structure than a tuple, then we can define a record.\n\n*)\n\ntype RecordExample = \n    { BeginningPrice : float \n      EndingPrice : float \n      Dividend : float }      \n\n(** And construct a value with that record type.*)\nlet x = { BeginningPrice = 100.0; EndingPrice = 110.0; Dividend = 0.0}\n(*** include-fsi-output ***)\n(** Similar to tuples, we can deconstruct our record value \u0060x\u0060 using pattern matching.*)\nlet { BeginningPrice = aa; EndingPrice = bb; Dividend = cc} = x\n(*** include-fsi-output ***)\n(** We can also access individual fields by name.*)\nx.EndingPrice / x.BeginningPrice\n(*** include-fsi-output ***)\n\n(** We can define a return function that operates on the \u0060RecordExample\u0060 type explicitly:*)\n\nlet simpleReturnRecord1 { BeginningPrice = beginningPrice; EndingPrice = endingPrice; Dividend = dividend} =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (endingPrice \u002B dividend) / beginningPrice - 1.0\n\n(** Or we can let the compiler\u0027s type inference figure out the input type.*)\nlet simpleReturnRecord2 x =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (x.EndingPrice \u002B x.Dividend) / x.BeginningPrice - 1.0\n\n(** Or we can provide a type hint to tell the compiler the type of the input.*)\nlet simpleReturnRecord3 (x : RecordExample) =\n    // This is solving for \u0060r\u0060 in FV = PV*(1\u002Br)^t where t=1.\n    (x.EndingPrice \u002B x.Dividend) / x.BeginningPrice - 1.0\n\n(** All 3 can be used interchangably, but when you have many similar types a type hint may be necessary to make the particular type that you want explicit.*)\n\nsimpleReturnRecord1 x\n(*** include-fsi-output ***)\nsimpleReturnRecord2 x\n(*** include-fsi-output ***)\nsimpleReturnRecord3 x\n(*** include-fsi-output ***)\n\n\n\n(**\n### Pipelines and lambda expressions\nThis download code used pipelining and lambda functions, which are two important language features. Pipelines are created using the pipe operator (\u0060|\u003E\u0060) and allow you to pipe the output of one function to the input of another. Lambda expressions allow you to create functions on the fly. \n\n*)\n\n1.0 |\u003E fun x -\u003E x \u002B 1.0 |\u003E fun x -\u003E x ** 2.0\n(*** include-fsi-output ***)\n\n(**\n### Collections: Arrays, Lists, Sequences\n\n*)\n\n(** A simple int array.*)\n\nlet ar = [| 0 .. 10 |] \n(** *)\nar |\u003E Array.take 5\n(*** include-fsi-output ***)\n\n(**\nWhen we look at the type signature of the elements in the array \u0060val ar : int []\u0060, it tells us that we have a integer array, meaning an array in which each element of the array is an integer. Arrays are \u0022zero indexed\u0022, meaning the 0th item is the first in the array. We can access the elements individually or use a range to access multiple together.\n*)\n\nar.[0]\n(*** include-fsi-output ***)\nar.[0 .. 2]\n(*** include-fsi-output ***)\n\n(** A simple float array.*)\nlet arr = [| 1.0 .. 10.0 |]\narr.[0]\narr.[0 .. 5]\n(*** include-fsi-output ***)\n\n(** Lists and sequences are similar. *)\n// List\n[ 1.0 .. 10.0 ]\n// Sequence\nseq { 1.0 .. 10.0 }\n\n(** Arrays, lists, and sequences have different properties that can make one data structure preferable to the others in a given setting. We\u0027ll discuss these different properties in due time, but for an overview you can see the F# collection language reference [here](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/fsharp-collection-types). Sequences are the most different as they are \u0022lazy\u0022, meaning \u0022Sequences are particularly useful when you have a large, ordered collection of data but don\u0027t necessarily expect to use all the elements. Individual sequence elements are computed only as required, so a sequence can perform better than a list if not all the elements are used\u0022 (see F# language reference).\n\nThese collections have several built-in functions for operating on them such as map, filter, groupBy, etc.*)\n\narr\n|\u003E Array.map(fun x -\u003E x \u002B 1.0)\n(*** include-fsi-output ***)\n\narr\n|\u003E Array.filter(fun x -\u003E x \u003C 5.0)\n(*** include-fsi-output ***)\narr\n|\u003E Array.groupBy(fun x -\u003E x \u003C 5.0)\n|\u003E Array.map(fun (group, xs) -\u003E Array.min xs, Array.max xs)\n(*** include-fsi-output ***)\n\n(**\n## Working with data\n\nWith this foundation, let\u0027s now try loading some data. We are going to obtain and process the data using an external F# library called [FSharp.Data](https://github.com/fsprojects/FSharp.Data) that makes the processing easier. \n\n### Namespaces\nFirst, let\u0027s create a file directory to hold data. We are going to use built-in dotnet IO (input-output) libraries to do so.\n\n*)\n// Set working directory to the this code file\u0027s directory\nSystem.IO.Directory.SetCurrentDirectory(__SOURCE_DIRECTORY__)\n// Now create cache directory one level above the working directory\nSystem.IO.File.WriteAllLines(\u0022test.txt\u0022,[\u0022first\u0022;\u0022second\u0022]) \n\n(** This illustrates the library namespace hierarchy. If we want to access the function within the hierarchy without typing the full namespace repetitively, we can open it. The following code is equivalent.\n\n\u0060\u0060\u0060\nopen System.IO\nDirectory.SetCurrentDirectory(__SOURCE_DIRECTORY__)\nFile.WriteAllLines(\u0022test.txt\u0022,[\u0022first\u0022;\u0022second\u0022]) \n\u0060\u0060\u0060\n\nIt is common to open the System namespace\n*)\n\nopen System\n\n(**\n### API keys\nWe are going to request the data from the provider [tiingo](https://api.tiingo.com/). Make sure that you are signed up and have your [API token](https://api.tiingo.com/documentation/general/connecting). An [API](https://en.wikipedia.org/wiki/API) (application programming interface) allows you to write code to communicate with another program. In this case we are goig to write code that requests stock price data from tiingo\u0027s web servers.\n\nOnce you have your api key, create a file called \u0060secrets.fsx\u0060 and save it at the root/top level of your project folder. In \u0060secrets.fsx\u0060, assign your key to a value named \u0060tiingoKey\u0060. If you are using git, make sure to add \u0060secrets.fsx\u0060 to your \u0060.gitignore\u0060 file.\n\n\u0060\u0060\u0060fsharp\nlet tiingoKey = \u0022yourSuperSecretApiKey\u0022\n\u0060\u0060\u0060\n\nWe can load this in our interactive session as follows, assuming that \u0060secrets.fsx\u0060 is located one folder above the current one in the file system.\n\n*)\n\n(***do-not-eval***)\n#load \u0022secrets.fsx\u0022\n\n(** and we can access the value by typing \n\u0060\u0060\u0060\nSecrets.tiingoKey\n\u0060\u0060\u0060\n*)\n\n(**\n### FSharp.Data Csv Type Provider\nWe\u0027re now going to process our downloaded data using the **FSharp.Data** [Csv Type Provider](http://fsprojects.github.io/FSharp.Data/library/CsvProvider.html). This is code that automatically defines the types of input data based on a sample. We have already reference the nuget packaged and opened the namespace, so we can just use it now.\n*)\n\n#load \u0022Common.fsx\u0022\nopen Common\n\n\nlet aapl = \n    \u0022AAPL\u0022\n    |\u003E Tiingo.request\n    |\u003E Tiingo.get  \n\naapl\n|\u003E Array.take 5\n(***include-it***)\n\n\n(**\n### Plotting\nNow let\u0027s plot the stock price using [Plotly.NET](https://plotly.github.io/Plotly.NET/).\n*)\n\n#r \u0022nuget: Plotly.NET, 2.0.0-beta5\u0022\nopen Plotly.NET\n\n\nlet sampleChart =\n    aapl\n    |\u003E Seq.map(fun x -\u003E x.Date, x.AdjClose)\n    |\u003E Chart.Line\n\n(***do-not-eval***)\nsampleChart |\u003E Chart.Show   \n\n(***hide***)\nsampleChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***) \n\n(**\nLet\u0027s calculate returns for this data. Typically we calculate close-close returns. Looking at the data, we could use the \u0060close\u0060, \u0060divCash\u0060, and \u0060splitFacor\u0060 columns to calculate returns accounting for stock splits and dividends (a good at home exercise). But there is also an \u0060adjClose\u0060 column that accounts for both those things. So we we can use this\n*)\n\n// Returns\nlet returns = \n    aapl\n    |\u003E Seq.sortBy(fun x -\u003E x.Date)\n    |\u003E Seq.pairwise\n    |\u003E Seq.map(fun (a,b) -\u003E b.Date, calcReturn (float a.AdjClose) (float b.AdjClose))\n\nlet avgReturnEachMonth = \n    returns\n    |\u003E Seq.groupBy(fun (date, ret) -\u003E DateTime(date.Year, date.Month,1))\n    |\u003E Seq.map(fun (month, xs) -\u003E month, Seq.length xs, xs |\u003E Seq.averageBy snd)\n\n(** We can look at a few of these*)\navgReturnEachMonth |\u003E Seq.take 3 |\u003E Seq.toList\n(***include-fsi-output***)\n\n(** The default DateTime printing is too verbose if we don\u0027t care about time. We can simplify the printing:*)\nfsi.AddPrinter\u003CDateTime\u003E(fun dt -\u003E dt.ToString(\u0022s\u0022))    \navgReturnEachMonth |\u003E Seq.take 3 |\u003E Seq.toList\n(***include-fsi-output***)\n\nlet monthlyReturnChart =\n    avgReturnEachMonth\n    |\u003E Seq.map(fun (month, cnt, ret) -\u003E month, ret)\n    |\u003E Chart.Bar\n\n(***do-not-eval***)\nmonthlyReturnChart |\u003E Chart.Show\n(***hide***)\nmonthlyReturnChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***) \n\n(**\n## Volatility\nWe represent volatility by the standard deviation of returns. We can define a standard deviation function ourself.\n*)\n\nlet stddev xs =\n    let mu = xs |\u003E Seq.average\n    let sse = xs |\u003E Seq.sumBy(fun x -\u003E (x - mu)**2.0)\n    let n = xs |\u003E Seq.length |\u003E float\n    sqrt (sse / (n - 1.0))\n\n[1.0 .. 10.0 ] |\u003E stddev    \n(***include-fsi-output***)\n\n(**\nBut it is also convenient to use the [FSharp.Stats](https://fslab.org/FSharp.Stats/)\n*)\n\n#r \u0022nuget: FSharp.Stats, 0.4.0\u0022\n\nopen FSharp.Stats\n[1.0 .. 10.0 ] |\u003E Seq.stDev\n(***include-fsi-output***)\n\n(** Now let\u0027s look at 5-day rolling volatilities.*)\n\nlet rollingVols =\n    returns\n    // Sort by date again because you never can be too careful\n    // about making sure that you have the right sort order.\n    |\u003E Seq.sortBy fst \n    |\u003E Seq.windowed 5\n    |\u003E Seq.map(fun xs -\u003E\n        let maxWindowDate = xs |\u003E Seq.map fst |\u003E Seq.max\n        let dailyVol = xs |\u003E Seq.stDevBy snd\n        let annualizedVolInPct = dailyVol * sqrt(252.0) * 100.0\n        maxWindowDate, annualizedVolInPct)\n\nlet volChart = \n    rollingVols\n    |\u003E Chart.Line\n\n(***do-not-eval***)\nvolChart |\u003E Chart.Show    \n(***hide***)\nvolChart |\u003E GenericChart.toChartHTML\n(*** include-it-raw ***) "},{"uri":"/Teaching/quizzes/discriminatedUnion-practiceQuiz.html","title":"Dicriminated Union","content":"(**\n---\ntitle: Dicriminated Union\ncategory: Practice Quizzes\ncategoryindex: 1\nindex: 5\n---\n*)\n\n(*** hide ***)\n/// example fast binder url: https://mybinder.org/v2/gh/fsprojects/fsharp.formatting/master?urlpath=git-pull?repo=https:/nhirschey.github.com/teaching/gh-pages/fundamentals.ipynb\n\n(**\n[![Binder](../images/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../images/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../images/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(** \n\nThis practice quiz emphasizes \u0060Discriminated Unions\u0060. They are useful for times when the data that you\u0027re representing has multiple mutually exclusive cases. \n\nHere is some good background reading for before you do these quesitions, particularly the F# for fun and profit link.\n\n- Discriminated Union types\n\n    - The F# language reference for [discriminated unions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/discriminated-unions)\n    - If you want more a more in depth discussion, see F# for fun and profit\u0027s section on [discriminated unions](https://fsharpforfunandprofit.com/posts/discriminated-unions/)\n    - The tour of F# section on [discriminated unions](https://docs.microsoft.com/en-us/dotnet/fsharp/tour#record-and-discriminated-union-types)\n\n*)\n\n(**\n## Question 1\nCreate a discriminated union named \u0060Action\u0060 with two cases: Buy and Sell.\n\n1. Create a value named \u0027bAction\u0027 and assign \u0060Buy\u0060 to it.\n2. Create a value named \u0027sAction\u0027 and assign \u0060Sell\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: createBuySell, define-output: createBuySell ***)\n\ntype Action = \n    | Buy \n    | Sell\n\nlet bAction = Buy\nlet sAction = Sell\n\n(*** condition:html, include:createBuySell ***)\n(*** condition:html, include-fsi-output:createBuySell ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nCreate a single case discriminated union to represent a particular kind of string:\n\n1. Create a discriminated union named Ticker with a single case Ticker of string. \n2. Then wrap the string \u0022ABC\u0022 in your Ticker type and assign it to a value named \u0027aTicker\u0027.\n3. Then use pattern matching to unwrap the string in \u0060aTicker\u0060 and assign it to a value named \u0060aTickerString\u0060.\n\nDiscriminated unions like this are usful if you want to make \nsure that you don\u0027t accidentally mix up two strings that represent\ndifferent things.\nA function that takes an input with type \u0060Ticker\u0060 will not accept any string,\nit will only accept inputs that have time Ticker.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: singleString, define-output: singleString ***)\n\ntype Ticker = Ticker of string\n\nlet aTicker = Ticker \u0022ABC\u0022\nlet (Ticker aTickerString) = aTicker\n\n(*** condition:html, include:singleString ***)\n(*** condition:html, include-fsi-output:singleString ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nCreate a single case discriminated union to represent a particular kind of float:\n\n1. Create a discriminated union named Signal with a single case Signal of float. \n2. Then wrap the string float \u00601.0\u0060 in your Signal type and assign it to a value named \u0027aSignal\u0027.\n3. Then use pattern matching to unwrap the float in \u0060aSignal\u0060 and assign it to a value named \u0060aSignalFloat\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: singleFloat, define-output: singleFloat ***)\n\ntype Signal = Signal of float\n\nlet aSignal = Signal 1.2\nlet (Signal aSignalFloat) = aSignal\n\n(*** condition:html, include:singleFloat ***)\n(*** condition:html, include-fsi-output:singleFloat ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nCreate a discriminated union called called \u0060Funds\u0060 with two cases: MutualFund of string and HedgeFund of string.\n\n1. Create a MutualFund case of the Fund union with the string \u0022Fidelity Magellan\u0022. Assign it to a value named \u0022magellan\u0022.\n2. Create a HedgeFund case of the Fund union with the string \u0022Renaissance Medallion\u0022. Assign it to a value named \u0022renaissance\u0022.\n\n*)  \n\n(*** include-it-raw:preDetails ***)\n(*** define: twoCaseString, define-output: twoCaseString ***)\n\ntype Funds =\n    | MutualFund of string\n    | HedgeFund of string\n\nlet magellan = MutualFund \u0022Fidelity Magellan\u0022\nlet renaissance = HedgeFund \u0022Renaissance Medallion\u0022\n\n(*** condition:html, include:twoCaseString ***)\n(*** condition:html, include-fsi-output:twoCaseString ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nDefine two types with the same cases.\n*)\n\ntype Ambiguous1 = Up | Down\ntype Ambiguous2 = Up | Down\n\n(**\nIf you try to assign Ambiguous1 to values, \nit can be hard for the compiler (and yourself)\nto figure out which of these types you mean. If you write \u0060Up\u0060\nthe compiler will think that you meant to use whatever was defined\nlast (Ambigous2).\n\nUse fully qualified names to show how to assign the \u0060Up\u0060 case from Ambiguous1 to\na value named \u0060ambiguous1\u0060 and the \u0060Up\u0060 case from Ambiguous2 to a value named\n\u0060ambiguous2\u0060. \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: clarifyAmbiguity, define-output: clarifyAmbiguity ***)\n\ntype Ambiguous1 = Up | Down\ntype Ambiguous2 = Up | Down\n\nlet ambiguous1 = Ambiguous1.Up\nlet ambiguous2 = Ambiguous2.Up\n\n(*** condition:html, include:clarifyAmbiguity ***)\n(*** condition:html, include-fsi-output:clarifyAmbiguity ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nImagine that analyst recommendations have the form\n*)\n\ntype AnalystRec = Buy | Sell | Hold\n\n(**\nYou have recommendations from two analysts\n*)\n\nlet goldmanRec = Buy\nlet barclaysRec = Sell\n\n(**\nYou want to act on goldman recommendations as follows:\n*)\nlet actionOnGoldman (x: AnalystRec) =\n    match x with\n    | Buy | Hold -\u003E \u0022I am buying this!\u0022\n    | Sell -\u003E \u0022I am selling this!\u0022\n\n(**\nThe problem is that this \u0060actionOnGoldman\u0060 function will\nwork for both \u0060goldmanRec\u0060 and \u0060barclaysRec\u0060.\n*)\n\nactionOnGoldman goldmanRec // evaluates to \u0022I am buying this!\u0022\nactionOnGoldman barclaysRec // evaluates to \u0022I am selling this!\u0022\n\n(**\n1. Create a single case union called \u0060GoldmanRec\u0060 where the single case\nis GoldmanRec of AnalystRec. \n2. Create a modified \u0060actionOnGoldman\u0060 function called \u0060actionOnGoldmanOnly\u0060 so that it will only work on recommendations with the type \u0060GoldmanRec\u0060.\n\nIf \u0060wrappedGoldmanRec\u0060 is buy \u0060GoldmanRec\u0060, the result should be\n\u0060\u0060\u0060fsharp\nactionOnGoldmanOnly wrappedGoldmanRec // evaluates to \u0022I am buying this!\u0022\nactionOnGoldmanOnly barclaysRec // compiler error.\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: funForSingleCase, define-output: funForSingleCase ***)\ntype AnalystRec = Buy | Sell | Hold\ntype GoldmanRec = GoldmanRec of AnalystRec\n\nlet goldmanRec = Buy\nlet barclaysRec = Sell\n\nlet actionOnGoldman (x: AnalystRec) =\n    match x with\n    | Buy | Hold -\u003E \u0022I am buying this!\u0022\n    | Sell -\u003E \u0022I am selling this!\u0022\n(*** condition:html, include:funForSingleCase ***)\n(*** condition:html, include-fsi-output:funForSingleCase ***)\n\n(**\nWhat we want:\n*)\n\n(*** define: funForSingleCase1, define-output: funForSingleCase1 ***)\nactionOnGoldman goldmanRec\n(*** condition:html, include:funForSingleCase1 ***)\n(*** condition:html, include-fsi-output:funForSingleCase1 ***)\n\n(**\nOops, we only want actionOnGoldman to work for Goldman recommendation.\n*)\n\n(*** define: funForSingleCase1, define-output: funForSingleCase1 ***)\nactionOnGoldman barclaysRec\n(*** condition:html, include:funForSingleCase1 ***)\n(*** condition:html, include-fsi-output:funForSingleCase1 ***)\n\n(**\n---\n** Actual answer starts here **\n\nConstructing created value from scratch:\n*)\n\n(*** define: funForSingleCase2, define-output: funForSingleCase2 ***)\nlet wrappedGoldmanRec = GoldmanRec Buy\n(*** condition:html, include:funForSingleCase2 ***)\n(*** condition:html, include-fsi-output:funForSingleCase2 ***)\n\n(**\nor, wrapping our previously created value:\n*)\n\n(*** define: funForSingleCase3, define-output: funForSingleCase3 ***)\nlet wrappedGoldmanRec2 = GoldmanRec goldmanRec\nwrappedGoldmanRec = wrappedGoldmanRec2 // true\n(*** condition:html, include:funForSingleCase3 ***)\n(*** condition:html, include-fsi-output:funForSingleCase3 ***)\n\n(**\nNow, constructing recommendation function from scratch:\n*)\n\n(*** define: funForSingleCase4, define-output: funForSingleCase4 ***)\nlet actionOnGoldmanOnly (x: GoldmanRec) =\n    match x with\n    | GoldmanRec Buy | GoldmanRec Hold -\u003E \u0022I am buying this!\u0022\n    | GoldmanRec Sell -\u003E \u0022I am selling this!\u0022\n(*** condition:html, include:funForSingleCase4 ***)\n(*** condition:html, include-fsi-output:funForSingleCase4 ***)\n\n(**\nor, constructing it from scratch with pattern matching:  \n*)\n\n(*** define: funForSingleCase5, define-output: funForSingleCase5 ***)\nlet actionOnGoldmanOnly2 (GoldmanRec x) =\n    // Since we unwrapped the goldman recommendation,\n    // now it is just the inner analyst recommendation.\n    // We can leave off the GoldmanRec that was wrapping the\n    // recomendation.\n    match x with\n    | Buy | Hold -\u003E \u0022I am buying this!\u0022\n    | Sell -\u003E \u0022I am selling this!\u0022\n(*** condition:html, include:funForSingleCase5 ***)\n(*** condition:html, include-fsi-output:funForSingleCase5 ***)\n\n(**\nor, since you see above that once we unwrap the goldman rec,\nit is the same as our original function.\n*)\n\n(*** define: funForSingleCase6, define-output: funForSingleCase6 ***)\nlet actionOnGoldmanOnly3 (GoldmanRec x) = actionOnGoldman x\n(*** condition:html, include:funForSingleCase6 ***)\n(*** condition:html, include-fsi-output:funForSingleCase6 ***)\n\n(**\nNow let\u0027s check the results.\nAll the alternatives should return the same result.\n*)\n\n(*** define: funForSingleCase7, define-output: funForSingleCase7 ***)\nlet Goldman1 = actionOnGoldmanOnly wrappedGoldmanRec\nlet Goldman2 = actionOnGoldmanOnly2 wrappedGoldmanRec\nlet Goldman3 = actionOnGoldmanOnly3 wrappedGoldmanRec\n(*** condition:html, include:funForSingleCase7 ***)\n(*** condition:html, include-fsi-output:funForSingleCase7 ***)\n\n(**\n\u0060\u0060\u0060fsharp\nactionOnGoldmanOnly barclaysRec //compiles to error\nactionOnGoldmanOnly2 barclaysRec //compiles to error\nactionOnGoldmanOnly3 barclaysRec //compiles to error\n\u0060\u0060\u0060\nThese would all give compiler errors. \nSo now we have what we want, actionOnGoldmanOnly only works for Goldman recommendations.\n*)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nImagine that stock tips have the form\n*)\n\ntype StockTip = Buy | Sell | Hold\n\n(**\nYou have recommendations from two people\n*)\n\nlet friendRec = Buy\nlet professorRec = Sell\n\n(**\nYou want to actions as follows:\n*)\n\nlet actionOnFriend (x: StockTip) = x\nlet actionOnProfessor (x: StockTip) =\n    match x with\n    | Buy -\u003E StockTip.Sell\n    | Hold -\u003E StockTip.Sell\n    | Sell -\u003E StockTip.Buy\n\n(**\n\n1. Create a two case union called \u0060FriendOrFoe\u0060 where the two cases are Friend of StockTip and Professor of StockTip.\n2. Create a function called \u0060actionFriendOrFoe\u0060 that will properly handle tips from friends and tips from professors.\n\nShow that \u0060friendRec\u0060 and \u0060professorRec\u0060 wrapped in the \u0060FriendOrFoe\u0060 type are handled properly by \u0060actionFriendOrFoe\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: funForTwoCases, define-output: funForTwoCases ***)\ntype StockTip = Buy | Sell | Hold\n\nlet friendRec = Buy\nlet professorRec = Sell\n\nlet actionOnFriend (x: StockTip) = x\nlet actionOnProfessor (x: StockTip) =\n    match x with\n    | Buy -\u003E StockTip.Sell\n    | Hold -\u003E StockTip.Sell\n    | Sell -\u003E StockTip.Buy\n(*** condition:html, include:funForTwoCases ***)\n(*** condition:html, include-fsi-output:funForTwoCases ***)\n\n(**\nor, since we\u0027re doing the same thing with a professor\u0027s\nBuy or Hold recommendation, this could also be written\n*)\n\n(*** define: funForTwoCases1, define-output: funForTwoCases1 ***)\nlet actionOnProfessor2 (x: StockTip) =\n    match x with\n    | Buy | Hold -\u003E StockTip.Sell\n    | Sell -\u003E StockTip.Buy\n\ntype FriendOrFoe = \n    | Friend of StockTip\n    | Professor of StockTip\n\nlet wrappedFriendRec = Friend friendRec\nlet wrappedProfessorRec = Professor professorRec\n\nlet actionOnFriendOrFoe (x: FriendOrFoe) =\n    match x with\n    | Friend tip -\u003E actionOnFriend tip\n    | Professor tip -\u003E actionOnProfessor tip \n(*** condition:html, include:funForTwoCases1 ***)\n(*** condition:html, include-fsi-output:funForTwoCases1 ***)\n\n(*** define: funForTwoCases2, define-output: funForTwoCases2 ***)\nlet friendOrFoe1 = actionOnFriendOrFoe wrappedFriendRec // evaluates to Buy\nlet friendOrFoe2 = actionOnFriendOrFoe wrappedProfessorRec // evaluates to Buy\nlet friendOrFoe3 = actionOnFriendOrFoe (Professor Hold) // evaluates to Sell\n(*** condition:html, include:funForTwoCases2 ***)\n(*** condition:html, include-fsi-output:funForTwoCases2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution."},{"uri":"/Teaching/quizzes/Option-Match-Map-practiceQuiz.html","title":"Option Match Map","content":"(**\n---\ntitle: Option Match Map\ncategory: Practice Quizzes\ncategoryindex: 1\nindex: 4\n---\n*)\n\n(**\n[![Binder](../images/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../images/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../images/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\nThis practice quiz emphasizes \u0060Optional types\u0060, \u0060Match expressions\u0060, and \u0060Map Collections\u0060. These are some features that we will use in building a portfolio.\n\nHere are some references to these topics. Please read the F# language reference links before proceeding with the questions. The other links (F# tour and F# for fun and profit) provide additional background and examples but are not necessary:\n\n- Option types\n\n    - The F# language reference for [options](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/options)\n    - The tour of F# section on [options](https://docs.microsoft.com/en-us/dotnet/fsharp/tour#optional-types)\n    - If you want more a more in depth discussion, see F# for fun and profit\u0027s section on [options](https://fsharpforfunandprofit.com/posts/the-option-type/)\n\n- Pattern matching using match expressions.\n\n    - [F# Language reference](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/match-expressions)\n    - [Tour of F#](https://docs.microsoft.com/en-us/dotnet/fsharp/tour#pattern-matching)\n    - [F# for fun and profit](https://fsharpforfunandprofit.com/posts/match-expression/)\n\n- Map collections.\n\n    - [F# Wikibook](https://en.wikibooks.org/wiki/F_Sharp_Programming/Sets_and_Maps#Maps)\n\n*)\n\n(**\n# Options\n*)\n\n(**\n## Question 1\nCreate a value named \u0060a\u0060 and assign \u0060Some 4\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: aSome4, define-output: aSome4 ***)\n\nlet a = Some 4\n\n(*** condition:html, include:aSome4 ***)\n(*** condition:html, include-fsi-output:aSome4 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nCreate a value name \u0060b\u0060 and assign \u0060None\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: bNone, define-output: bNone ***)\n\nlet b = None\n\n(*** condition:html, include:bNone ***)\n(*** condition:html, include-fsi-output:bNone ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nCreate a tuple named \u0060c\u0060 and assign \u0060(Some 4, None)\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: cSome4None, define-output: cSome4None ***)\n\nlet c = Some 4, None\n\n(*** condition:html, include:cSome4None ***)\n(*** condition:html, include-fsi-output:cSome4None ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nWrite a function named d that takes \u0060x: float\u0060 as an input and outputs\n\u0060Some x\u0060 if x \u003C 0 and \u0060None\u0060 if x \u003E= 0. Test it by mapping each element of\n\u0060[0.0; 1.4; -7.0]\u0060 by function d.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: dFunction, define-output: dFunction ***)\nlet d (x: float) = if x \u003C 0.0 then Some x else None\n[0.0; 1.4;-7.0] |\u003E List.map d\n(*** condition:html, include:dFunction ***)\n(*** condition:html, include-fsi-output:dFunction ***)\n\n(**\nor, we don\u0027t actually have to tell it that \u0060x\u0060 is a \u0060float\u0060\nbecause type inference can tell that \u0060x\u0060 must be a \u0060float\u0060\nbecause the function does \u0060x \u003C 0.0\u0060 and \u00600.0\u0060 is a \u0060float\u0060.\n*)\n\n(*** define: dFunction1, define-output: dFunction1 ***)\nlet d2 x = if x \u003C 0.0 then Some x else None\n[0.0; 1.4;-7.0] |\u003E List.map d2\n(*** condition:html, include:dFunction1 ***)\n(*** condition:html, include-fsi-output:dFunction1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nConsider this array of trading days for a stock and it\u0027s price and dividends:\n*)\n\ntype StockDays = { Day : int; Price : decimal; Dividend : decimal Option }\nlet stockDays = \n    [| for day = 0 to 5 do \n        let dividend = if day % 2 = 0 then None else Some 1m\n        { Day = day\n          Price = 100m \u002B decimal day\n          Dividend = dividend } |]   \n\n(**\n1. create a new array called \u0060stockDaysWithDividends\u0060 that is a filtered\n  version of \u0060stockDays\u0060 that only contains days with dividends. \n2. Then create an array called \u0060stockDaysWithoutDividends\u0060 that is a filtered\n  version of \u0060stockDays\u0060 that only contains days that do not have dividends.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: stockDayswithDividends, define-output: stockDayswithDividends ***)\nlet stockDaysWithDivideds =\n    stockDays\n    |\u003E Array.filter(fun day -\u003E \n        // variable names are arbitrary, but it\u0027s helpful to use\n        // meaningful names like \u0022day\u0022 if the record that our\n        // function is operating on represents a day.\n        // using a variable named day to represent the day record\n        day.Dividend.IsSome)\n(*** condition:html, include:stockDayswithDividends ***)\n(*** condition:html, include-fsi-output:stockDayswithDividends ***)\n\n(*** define: stockDayswithDividends1, define-output: stockDayswithDividends1 ***)\nlet stockDaysWithoutDividends =\n    stockDays\n    |\u003E Array.filter(fun x -\u003E \n        // using a variable named x to represent the day record.\n        // less clear by looking at this code that x is a day.\n        x.Dividend.IsNone)\n(*** condition:html, include:stockDayswithDividends1 ***)\n(*** condition:html, include-fsi-output:stockDayswithDividends1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nConsider the value \u0060let nestedOption = (Some (Some 4))\u0060. Pipe\nit to \u0060Option.flatten\u0060 so that you are left with \u0060Some 4\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: nestedOption, define-output: nestedOption ***)\n\nlet nestedOption = (Some (Some 4))\nnestedOption |\u003E Option.flatten\n// this would also work, but doesn\u0027t use a pipe\nOption.flatten nestedOption\n\n(*** condition:html, include:nestedOption ***)\n(*** condition:html, include-fsi-output:nestedOption ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nConsider this list \u0060let listOfNestedOptions = [(Some (Some 4)); Some (None); None]\u0060.\nShow how to transform it into \u0060[Some 4; None; None]\u0060 by mapping a function to each\nelement of the list. \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listOfNestedOptions, define-output: listOfNestedOptions ***)\n\nlet listOfNestedOptions = [(Some (Some 4)); Some (None); None]\n// map the function Option.flatten to each element of the list\nlistOfNestedOptions |\u003E List.map Option.flatten\n\n\n(*** condition:html, include:listOfNestedOptions ***)\n(*** condition:html, include-fsi-output:listOfNestedOptions ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Match Expressions\n*)\n\n(**\n## Question 1\nWrite a function named \u0060ma\u0060 that takes \u0060x: float Option\u0060 as an input.\nUse a match expression to output the \u0060float\u0060 if \u0060x\u0060 is something and\n\u00600.0\u0060 if the \u0060float\u0060 is nothing. Provide a test case for both cases to show\nthat the function works.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: maFunction, define-output: maFunction ***)\nlet ma x = \n    match x with\n    | None -\u003E 0.0\n    | Some y -\u003E y\n\nlet ma2Some7 = ma (Some 7.0) // returns 7.0\nlet ma2None = ma None // returns 0.0\n(*** condition:html, include:maFunction ***)\n(*** condition:html, include-fsi-output:maFunction ***)\n\n(**\nor, see the \u0060x\u0060 in the (\u0060Some x\u0060) part of the match expression\nis the \u0060float\u0060, not the original (\u0060x: float Option\u0060)\nTo see this, hover your cursor over the first two xs. it says \u0060x is float Option\u0060.\nThen hover over the second two xs. It says \u0060x is float\u0060. Two different xs!\n*)\n\n(*** define: maFunction1, define-output: maFunction1 ***)\nlet ma2 x = \n    match x with\n    | None -\u003E 0.0\n    | Some x -\u003E x\n\nlet ma2Some7Other = ma2 (Some 7.0) // returns 7.0\nlet ma2NoneOther = ma2 None // returns 0.0\n(*** condition:html, include:maFunction1 ***)\n(*** condition:html, include-fsi-output:maFunction1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nWrite a function named \u0060mb\u0060 that takes \u0060x: float\u0060 as an input.\nUse a match expression to output \u00601.0\u0060 if \u0060x\u0060 is \u00601.0\u0060, \u00604.0\u0060 if \u0060x\u0060 is \u00602.0\u0060,\nand \u0060x^3.0\u0060 if \u0060x\u0060 is anything else. Provide 3 tests for the 3 test cases \nto show that the function works.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mbFunction, define-output: mbFunction ***)\n\nlet mb x = \n    match x with \n    | 1.0 -\u003E 1.0\n    | 2.0 -\u003E 4.0\n    | x -\u003E x**3.0\n\nlet mb1 = mb 1.0 // evaluates to 1.0\nlet mb2 = mb 2.0 // evaluates to 4.0\nlet mb7 = mb 7.0 // evaluates to 343.00\n\n(*** condition:html, include:mbFunction ***)\n(*** condition:html, include-fsi-output:mbFunction ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nWrite a function named \u0060mc\u0060 that takes a tuple pair of ints  \u0060x: int * int\u0060\nas an input. Handle these cases in the following order:\n\n1. if the first \u0060int\u0060 is \u00607\u0060, return \u0060\u0022a\u0022\u0060.\n2. if the second int is \u00607\u0060, return \u0060\u0022b\u0022\u0060.\n3. For everything else, return \u0060\u0022c\u0022\u0060.\n\nFinally, test the function on \u0060(7,6)\u0060, \u0060(6,7)\u0060, \u0060(7, 7)\u0060, and \u0060(6,6)\u0060.\nMake sure that you understand how those 4 examples are handled.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mcFunction, define-output: mcFunction ***)\n\nlet mc x =\n    match x with\n    | (7, _) -\u003E \u0022a\u0022 // the _ in (7, _) indicates wildcard; it matches anything.\n    | (_, 7) -\u003E \u0022b\u0022 \n    | _ -\u003E \u0022c\u0022 // wild card at the end catches anything remaining.\n\nlet mc76 = mc (7,6) // evaluates to \u0022a\u0022 because it matches the first case and stops checking.\nlet mc67 = mc (6,7) // evaluates to \u0022b\u0022 because it matches the second case and stops checking.\nlet mc77 = mc (7,7) // evaluates to \u0022a\u0022 because it matches the first case and stops checking.\nlet mc66 = mc (6,6) // evaluates to \u0022c\u0022 because it matches the last wildcard.\n\n(*** condition:html, include:mcFunction ***)\n(*** condition:html, include-fsi-output:mcFunction ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nConsider this array of trading days for a stock and it\u0027s price and dividends:\n*)\n\ntype StockDays2 = { Day : int; Price : decimal; Dividend : decimal Option }\nlet stockDays2 = \n    [| for day = 0 to 5 do \n        let dividend = if day % 2 = 0 then None else Some 1m\n        { Day = day\n          Price = 100m \u002B decimal day\n          Dividend = dividend } |]   \n\n(**\n\n1. create a new array called \u0060daysWithDividends\u0060 that is a filtered\n  version of \u0060stockDays\u0060 that only contains days with dividends. For\n  each day with a dividend, you should return a \u0060(int * decimal)\u0060 tuple\n  where the int is the day  and the decimal is the dividend. \n  Thus the result is an \u0060(int * decimal) array\u0060.\n2. Then create an array called \u0060daysWithoutDividends\u0060 that is a filtered\n  version of \u0060stockDays\u0060 that only contains days that do not have dividends.\n  For each day without a dividend, you should return the day as an \u0060int\u0060.\n  Thus the result is an \u0060int array\u0060.\n\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nDays With Dividends: \n*)\n\n(*** define: daysWithAndWithoutDividends, define-output: daysWithAndWithoutDividends ***)           \nlet daysWithDividends1 =\n    // using filter and then a map\n    stockDays2\n    |\u003E Array.filter (fun day -\u003E day.Dividend.IsSome)\n    |\u003E Array.map(fun day -\u003E\n        match day.Dividend with\n        | None -\u003E failwith \u0022shouldn\u0027t happen because I filtered on IsSome\u0022\n        | Some div -\u003E day.Day, div)\n(*** condition:html, include:daysWithAndWithoutDividends ***)\n(*** condition:html, include-fsi-output:daysWithAndWithoutDividends ***)\n\n(**\nor\n*)\n\n(*** define: daysWithAndWithoutDividends1, define-output: daysWithAndWithoutDividends1 ***)           \nlet daysWithDividends2 =\n    // using choose, this is better. Think of choose\n    // as a filter on IsSome and a map combined. Choose applies\n    // a function that returns an option. If the\n    // option result is Some x then choose returns x.\n    // If the result is None then choose filters it out.\n    // Notice that we don\u0027t have to worry about \n    // the \u0022this shouldn\u0027t happen\u0022 exception\n    // because it literally cannot happen in this version.\n    // This is an example of making illegal states unrepresentable.\n    stockDays2\n    |\u003E Array.choose (fun day -\u003E \n        // our function takes a day as an input and outputs\n        // a \u0060(int * decimal) option\u0060. That is,\n        // an optional tuple.\n        match day.Dividend with \n        | None -\u003E None\n        | Some div -\u003E Some (day.Day, div))\n(*** condition:html, include:daysWithAndWithoutDividends1 ***)\n(*** condition:html, include-fsi-output:daysWithAndWithoutDividends1 ***)\n\n(**\nDays Without Dividends: \n*)\n\n(*** define: daysWithAndWithoutDividends2, define-output: daysWithAndWithoutDividends2 ***)           \nlet daysWithoutDividends =\n    stockDays2\n    |\u003E Array.choose(fun day -\u003E \n        match day.Dividend with\n        | None -\u003E Some day.Day\n        | Some div -\u003E None)\n(*** condition:html, include:daysWithAndWithoutDividends2 ***)\n(*** condition:html, include-fsi-output:daysWithAndWithoutDividends2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Map Collections\n*)\n\n(**\n## Question 1\nCreate a Map collection named \u0060mapA\u0060 \nfrom the list \u0060[(\u0022a\u0022,1);(\u0022b\u0022,2)]\u0060 where the first thing \nin the tuple is the key and the second thing is the value.\n\n1. Use \u0060Map.tryFind\u0060 to retrieve the value for key \u0060\u0022a\u0022\u0060\n2. Use \u0060Map.tryFind\u0060 to retrieve the value for key \u0060\u0022c\u0022\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nCreate Map Collection:\n*)\n\n(*** define: mapA, define-output: mapA ***)\nlet mapA = Map [(\u0022a\u0022,1);(\u0022b\u0022,2)]\n(*** condition:html, include:mapA ***)\n(*** condition:html, include-fsi-output:mapA ***)\n\n(**\nor\n*)\n\n(*** define: mapA2, define-output: mapA2 ***)\nlet mapA2 = [(\u0022a\u0022,1);(\u0022b\u0022,2)] |\u003E Map\n(*** condition:html, include:mapA2 ***)\n(*** condition:html, include-fsi-output:mapA2 ***)\n\n(**\nor\n*)\n\n(*** define: mapA3, define-output: mapA3 ***)\nlet mapA3 = [(\u0022a\u0022,1);(\u0022b\u0022,2)] |\u003E Map.ofList\n(*** condition:html, include:mapA3 ***)\n(*** condition:html, include-fsi-output:mapA3 ***)\n\n(**\nUse \u0060Map.tryFind\u0060 to retrieve the value for key \u0060\u0022a\u0022\u0060:\n*)\n\n(*** define: tryFindA, define-output: tryFindA ***)\nMap.tryFind \u0022a\u0022 mapA    // evaluates to Some 1\n(*** condition:html, include:tryFindA ***)\n(*** condition:html, include-fsi-output:tryFindA ***)\n\n(**\nor\n*)\n\n(*** define: tryFindA1, define-output: tryFindA1 ***)\nmapA |\u003E Map.tryFind \u0022a\u0022 // evaluates to Some 1\n(*** condition:html, include:tryFindA1 ***)\n(*** condition:html, include-fsi-output:tryFindA1 ***)\n\n(**\nUse \u0060Map.tryFind\u0060 to retrieve the value for key \u0060\u0022c\u0022\u0060:\n*)\n\n(*** define: tryFindC, define-output: tryFindC ***)\nMap.tryFind \u0022c\u0022 mapA    // evaluates to None\n(*** condition:html, include:tryFindC ***)\n(*** condition:html, include-fsi-output:tryFindC ***)\n\n(**\nor\n*)\n\n(*** define: tryFindC1, define-output: tryFindC1 ***)\nmapA |\u003E Map.tryFind \u0022c\u0022 // evaluates to None\n(*** condition:html, include:tryFindC1 ***)\n(*** condition:html, include-fsi-output:tryFindC1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nCreate a Map collection named \u0060mapB\u0060\nfrom the list \u0060[(1,\u0022a\u0022);(2,\u0022b\u0022)]\u0060 where the first thing\nin the tuple is the key and the second thing is the value.\n\n1. Use \u0060Map.tryFind\u0060 to retrieve the value for key \u00601\u0060\n2. Use \u0060Map.tryFind\u0060 to retrieve the value for key \u00603\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mapB, define-output: mapB ***)\n\nlet mapB = Map [(1,\u0022a\u0022);(2,\u0022b\u0022)]\nlet tryFindMapB1 = Map.tryFind 1 mapB\nlet tryFindMapB3 =Map.tryFind 3 mapB\n\n(*** condition:html, include:mapB ***)\n(*** condition:html, include-fsi-output:mapB ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nUse this array\n*)\n\ntype StockDays3 = { Day : int; Price : decimal; Dividend : decimal Option }\nlet stockDays3 = \n    [| for day = 0 to 5 do \n        let dividend = if day % 2 = 0 then None else Some 1m\n        { Day = day\n          Price = 100m \u002B decimal day\n          Dividend = dividend } |]     \n\n(**\n1. Create a Map collection named \u0060mapC\u0060. The key should be the day field, \n  and the value should be the full \u0060StockDays3\u0060 record.\n2. Create a Map collection named \u0060mapD\u0060. The key should be the full\n  \u0060StockDay3\u0060 record. The value should be the day field.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: mapC, define-output: mapC ***)    \nlet mapC =\n    stockDays3\n    |\u003E Array.map(fun day -\u003E\n        // we just want to create a tuple of the (key,value).\n        // The key and value can be anything.\n        day.Day, day)\n    |\u003E Map.ofArray\n(*** condition:html, include:mapC ***)\n(*** condition:html, include-fsi-output:mapC ***)\n\n(*** define: mapD, define-output: mapD ***)    \nlet mapD =\n    stockDays3\n    |\u003E Array.map(fun day -\u003E\n        // we just want to create a tuple of the (key,value).\n        // The key and value can be anything.\n        day, day.Day)\n    |\u003E Map.ofArray\n\n(*** condition:html, include:mapD ***)\n(*** condition:html, include-fsi-output:mapD ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nConsider a the following Map collection:\n*)\nlet mapp = [(\u0022a\u0022, 1); (\u0022d\u0022,7)] |\u003E Map.ofList\n\n(**\nWrite a function named \u0060lookFor\u0060 that takes \u0060x: string\u0060 as an input and\nlooks up the value in \u0060mapp\u0060. If it finds \u0060Some y\u0060, print\n\u0060\u0022I found y\u0022\u0060 to standard output where \u0060y\u0060 is the actual integer found. \nIf it finds \u0060None\u0060, print \u0060\u0022I did not find x\u0022\u0060 to standard output\nwhere \u0060x\u0060 is the actual key that was looked up. Test it by looking\nup \u0060\u0022a\u0022\u0060,\u0060\u0022b\u0022\u0060,\u0022\u0060c\u0022\u0060,\u0060\u0022d\u0022\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: lookFor, define-output: lookFor ***)    \nlet lookFor x =\n    match Map.tryFind x mapp with\n    | Some y -\u003E printfn $\u0022I found {y}\u0022\n    | None -\u003E printfn $\u0022I did not find {x}\u0022 \n\nlookFor \u0022a\u0022 // I found 1\nlookFor \u0022b\u0022 // I did not find b\nlookFor \u0022c\u0022 // I did not find c\nlookFor \u0022d\u0022 // I found 7\n(*** condition:html, include:lookFor ***)\n(*** condition:html, include-fsi-merged-output:lookFor ***)\n\n(**\nor iterate it\nwe use iter instead of map\nbecause the result of iter has type \u0060unit\u0060,\nand iter is for when your function has type \u0060unit\u0060.\nBasically, unit type means the function did something\n(in this case, printed to standard output) but\nit doesn\u0027t actually return any output.  \nYou could use map, but then we get \u0060unit list\u0060 which\nisn\u0027t really what we want. We just want to iterate\nthrough the list and print to output.\n*)\n\n(*** define: lookFor1, define-output: lookFor1 ***)    \n[\u0022a\u0022; \u0022b\u0022; \u0022c\u0022; \u0022d\u0022] |\u003E List.iter lookFor\n(*** condition:html, include:lookFor1 ***)\n(*** condition:html, include-fsi-merged-output:lookFor1 ***)\n\n(**\nor loop it\n*)\n\n(*** define: lookFor2, define-output: lookFor2 ***)    \nfor letter in [\u0022a\u0022; \u0022b\u0022; \u0022c\u0022; \u0022d\u0022] do\n    printfn $\u0022{lookFor letter}\u0022    \n(*** condition:html, include:lookFor2 ***)\n(*** condition:html, include-fsi-merged-output:lookFor2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Joins\n\nFor the following questions use this data:\n*)\ntype StockPriceOb =\n    { Stock : string \n      Time : int\n      Price : int }\n\ntype TwoStocksPriceOb =\n    { Time : int \n      PriceA : int option \n      PriceB : int option }\n\nlet stockA = \n    [{ Stock = \u0022A\u0022; Time = 1; Price = 5}\n     { Stock = \u0022A\u0022; Time = 2; Price = 6}]\n\nlet stockB =     \n    [{ Stock = \u0022B\u0022; Time = 2; Price = 5}\n     { Stock = \u0022B\u0022; Time = 3; Price = 4}]\n\n(**\nHint: remember that Map collections are useful for lookups.\n*)\n\n\n(**\n## Question 1\nCreate a \u0060TwoStocksPriceOb list\u0060 named \u0060tslA\u0060 that has prices for\nevery observation of \u0060stockA\u0060. If there is a price for \u0060stockB\u0060\nat the same time as \u0060stockA\u0060, then include the \u0060stockB\u0060 price. Otherwise,\nthe \u0060stockB\u0060 price should be \u0060None\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: TwoStockPriceOb, define-output: TwoStockPriceOb ***)    \nlet stockbByTime = \n    stockB \n    |\u003E List.map(fun day -\u003E day.Time, day)\n    |\u003E Map.ofList\n\nlet tslA1 =\n    stockA\n    |\u003E List.map(fun dayA -\u003E\n        let dayB = Map.tryFind dayA.Time stockbByTime\n        match dayB with\n        | None -\u003E \n            { Time = dayA.Time\n              PriceA = Some dayA.Price\n              PriceB = None}\n        | Some db -\u003E \n            { Time = dayA.Time\n              PriceA = Some dayA.Price \n              PriceB = Some db.Price })\n(*** condition:html, include:TwoStockPriceOb ***)\n(*** condition:html, include-fsi-output:TwoStockPriceOb ***)\n\n(**\nor, just a personal preference if you like the loop or List.map\n*)\n\n(*** define: TwoStockPriceOb1, define-output: TwoStockPriceOb1 ***)    \nlet tslA2 =\n    [ for dayA in stockA do \n        let dayB = Map.tryFind dayA.Time stockbByTime\n        match dayB with\n        | None -\u003E \n            { Time = dayA.Time\n              PriceA = Some dayA.Price\n              PriceB = None}\n        | Some db -\u003E \n            { Time = dayA.Time\n              PriceA = Some dayA.Price \n              PriceB = Some db.Price }]\n(*** condition:html, include:TwoStockPriceOb1 ***)\n(*** condition:html, include-fsi-output:TwoStockPriceOb1 ***)\n\n(**\nor, define a function\n*)\n\n(*** define: TwoStockPriceOb2, define-output: TwoStockPriceOb2 ***)    \nlet tryFindBforA (dayA: StockPriceOb) =\n    let dayB = Map.tryFind dayA.Time stockbByTime\n    match dayB with\n    | None -\u003E \n        { Time = dayA.Time\n          PriceA = Some dayA.Price\n          PriceB = None}\n    | Some db -\u003E \n        { Time = dayA.Time\n          PriceA = Some dayA.Price \n          PriceB = Some db.Price }   \n(*** condition:html, include:TwoStockPriceOb2 ***)\n(*** condition:html, include-fsi-output:TwoStockPriceOb2 ***)\n\n(**\ncheck it\n*)\n\n(*** define: TwoStockPriceOb3, define-output: TwoStockPriceOb3 ***)    \ntryFindBforA stockA.[0]  \n(*** condition:html, include:TwoStockPriceOb3 ***)\n(*** condition:html, include-fsi-output:TwoStockPriceOb3 ***)\n\n(**\ndo it\n*)\n\n(*** define: TwoStockPriceOb4, define-output: TwoStockPriceOb4 ***)    \nlet tslA3 = stockA |\u003E List.map tryFindBforA   \n(*** condition:html, include:TwoStockPriceOb4 ***)\n(*** condition:html, include-fsi-output:TwoStockPriceOb4 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nCreate a \u0060TwoStocksPriceOb list\u0060 named \u0060tslB\u0060 that has prices for\nevery observation of stockB. If there is a price for \u0060stockA\u0060\nat the same time as \u0060stockB\u0060, then include the \u0060stockA\u0060 price. Otherwise,\nthe \u0060stockA\u0060 price should be \u0060None\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: tslB, define-output: tslB ***)    \n\nlet stockaByTime = \n    stockA \n    |\u003E List.map(fun day -\u003E day.Time, day)\n    |\u003E Map.ofList\n\nlet tslB =\n    stockB\n    |\u003E List.map(fun dayB -\u003E\n        let dayA = Map.tryFind dayB.Time stockaByTime\n        match dayA with\n        | None -\u003E \n            { Time = dayB.Time\n              PriceA = None\n              PriceB = Some dayB.Price }\n        | Some da -\u003E \n            { Time = dayB.Time\n              PriceA = Some da.Price \n              PriceB = Some dayB.Price })                        \n\n(*** condition:html, include:tslB ***)\n(*** condition:html, include-fsi-output:tslB ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nCreate a \u0060TwoStocksPriceOb list\u0060 named \u0060tslC\u0060 that only includes times\nwhen there is a price for both \u0060stockA\u0060 and \u0060stockB\u0060. The prices for stocks\nA and B should always be something.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: tslC, define-output: tslC ***)    \nlet stockaByTime2 = \n    stockA \n    |\u003E List.map(fun day -\u003E day.Time, day)\n    |\u003E Map.ofList\n\nlet tslC1 =\n    stockB\n    |\u003E List.choose(fun dayB -\u003E\n        let dayA = Map.tryFind dayB.Time stockaByTime2\n        match dayA with\n        | None -\u003E None\n        | Some da -\u003E \n            let output =\n                { Time = dayB.Time\n                  PriceA = Some da.Price \n                  PriceB = Some dayB.Price }\n            Some output)\n(*** condition:html, include:tslC ***)\n(*** condition:html, include-fsi-output:tslC ***)\n\n(**\nor, using set which I know you do not know. But #yolo\n*)\n\n(*** define: tslC2, define-output: tslC2 ***)    \nlet timesA = stockA |\u003E List.map(fun x -\u003E x.Time) |\u003E set\nlet timesB = stockB |\u003E List.map(fun x -\u003E x.Time) |\u003E set\nlet timesAandB = Set.intersect timesA timesB\n\nlet tslC2 =\n    timesAandB\n    |\u003E Set.toList\n    |\u003E List.map(fun time -\u003E \n        { Time = time \n          PriceA = Some stockaByTime.[time].Price\n          PriceB = Some stockbByTime.[time].Price})        \n(*** condition:html, include:tslC2 ***)\n(*** condition:html, include-fsi-output:tslC2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nCreate a \u0060TwoStocksPriceOb list\u0060 named \u0060tslD\u0060 that includes available\nstock prices for \u0060stockA\u0060 and \u0060stockB\u0060 at all possible times. If a price for\none of the stocks is missing for a given time, it should be None.\n\n\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: tslD, define-output: tslD ***)    \nlet stockATimes = stockA |\u003E List.map(fun x -\u003E x.Time)\nlet stockBTimes = stockB |\u003E List.map(fun x -\u003E x.Time)\n\nlet allTimes = \n    List.append stockATimes stockBTimes\n    |\u003E List.distinct\n\nlet tslD =\n    allTimes\n    |\u003E List.map(fun time -\u003E\n        let a = \n            match Map.tryFind time stockaByTime with\n            | None -\u003E None\n            | Some a -\u003E Some a.Price\n            \n        let b = \n            // same thing as what\u0027s done above with match expression,\n            // but with Option.map. Personal preference depending\n            // on what seems clearest. If you\u0027re mapping an option\n            // and returning None for the None case,\n            // a Option.map can be nice.\n            Map.tryFind time stockbByTime\n            |\u003E Option.map(fun b -\u003E b.Price)\n        { Time = time; PriceA = a; PriceB = b })    \n(*** condition:html, include:tslD ***)\n(*** condition:html, include-fsi-output:tslD ***)\n\n(**\nor, using a function. This is the same thing as in the above\nanonymous lambda function, but I\u0027m going to use different \ncode to achieve the same goal just to show you different options.\nagain, it\u0027s just personal preference.\ncheck how to write the function using time = 1 as a test\n*)\n\n(*** define: tslD1, define-output: tslD1 ***)    \nlet testTime = 1\n\nlet time1A = Map.tryFind testTime stockaByTime\nlet time1B = Map.tryFind testTime stockbByTime\n\nlet time1Aprice = time1A |\u003E Option.map(fun x -\u003E x.Price )\nlet time1Bprice = time1B |\u003E Option.map(fun x -\u003E x.Price)\n\nlet testOutput = { Time = testTime; PriceA = time1Aprice; PriceB = time1Bprice }   \n(*** condition:html, include:tslD1 ***)\n(*** condition:html, include-fsi-output:tslD1 ***)\n\n(**\nnow turn above code into a function to do the same thing\n*)\n\n(*** define: tslD2, define-output: tslD2 ***)    \nlet getTheMatch time =\n    let a = Map.tryFind time stockaByTime\n    let b = Map.tryFind time stockbByTime\n    let aPrice = a |\u003E Option.map(fun x -\u003E x.Price)\n    let bPrice = b |\u003E Option.map(fun x -\u003E x.Price)\n    { Time = time; PriceA = aPrice; PriceB = bPrice }\n(*** condition:html, include:tslD2 ***)\n(*** condition:html, include-fsi-output:tslD2 ***)\n\n(**\ntest it to see that it works\n*)\n\n(*** define: tslD3, define-output: tslD3 ***)    \ngetTheMatch 1\ngetTheMatch 2\n(*** condition:html, include:tslD3 ***)\n(*** condition:html, include-fsi-output:tslD3 ***)\n\n(**\nnow do it for the whole list\n*)\n\n(*** define: tslD4, define-output: tslD4 ***)    \nlet tslD2 = allTimes |\u003E List.map getTheMatch   \n(*** condition:html, include:tslD4 ***)\n(*** condition:html, include-fsi-output:tslD4 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n"},{"uri":"/Teaching/quizzes/volatilityTiming-PracticeQuiz-2.html","title":"Volatility Timing Part 2","content":"(**\n---\ntitle: Volatility Timing Part 2\ncategory: Practice Quizzes\ncategoryindex: 1\nindex: 3\n---\n*)\n\n(**\n[![Binder](../images/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../images/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../images/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\nWe\u0027re going to use the following in the questions\n*)\n\n#r \u0022nuget: FSharp.Stats\u0022\n\nopen System\nopen FSharp.Stats\n\nfsi.AddPrinter\u003CDateTime\u003E(fun dt -\u003E dt.ToString(\u0022s\u0022))\n\ntype ReturnOb = { Symbol : string; Date : DateTime; Return : float }\ntype ValueOb = { Symbol : string; Date : DateTime; Value : float }\n\nlet seed = 1\nRandom.SetSampleGenerator(Random.RandBasic(seed))   \nlet normal = Distributions.Continuous.normal 0.0 0.1\n\nlet returns =\n    [| \n        for symbol in [\u0022AAPL\u0022; \u0022TSLA\u0022] do\n        for month in [1..2] do\n        for day in [1..3] do\n            { Symbol = symbol \n              Date = DateTime(2021, month, day)\n              Return = normal.Sample()}\n    |]\n\n\n(**\n## Question 1\n*)\n\n[| [| 1.0; 2.0|]\n   [| 3.0; 4.0|] |]\n\n(**\nTake this array of arrays, add \u00601.0\u0060 to each element of the \u0022inner\u0022 arrays,\nand then concatenate all the inner arrays together.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: arraysAdd1, define-output: arraysAdd1 ***)\n[| [| 1.0; 2.0|]\n   [| 3.0; 4.0|] |]\n|\u003E Array.collect(fun xs -\u003E xs |\u003E Array.map(fun x -\u003E x \u002B 1.0))\n(*** condition:html, include:arraysAdd1 ***)\n(*** condition:html, include-fsi-output:arraysAdd1 ***)\n\n(**\nor\n*)\n\n(*** define: arraysAdd1Other, define-output: arraysAdd1Other ***)\n[| [| 1.0; 2.0|]\n   [| 3.0; 4.0|] |]\n|\u003E Array.map(fun xs -\u003E xs |\u003E Array.map(fun x -\u003E x \u002B 1.0))\n|\u003E Array.concat\n\n(*** condition:html, include:arraysAdd1Other ***)\n(*** condition:html, include-fsi-output:arraysAdd1Other ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nTake the following two-parameter function:\n*)\n\nlet add x y = x \u002B y\n\n(**\nUse the above function and [partial application](https://fsharpforfunandprofit.com/posts/partial-application/)\nto define a new function called \n\u0060add2\u0060 that adds 2 \nto it\u0027s input.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: twoParaFunction, define-output: twoParaFunction ***)\n\nlet add2 = add 2\n\n(*** condition:html, include:twoParaFunction ***)\n(*** condition:html, include-fsi-output:twoParaFunction ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nGiven \u0060returns : ReturnOb []\u0060, use \u0060printfn\u0060 to print the whole\narray to standard output using the [structured plaintext formatter](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/plaintext-formatting). \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: printfnStructuredObject, define-output: printfnStructuredObject ***)\n\nreturns |\u003E (printfn \u0022%A\u0022)\n\n(*** condition:html, include:printfnStructuredObject ***)\n(*** condition:html, include-output:printfnStructuredObject ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nGiven the tuple \u0060(\u0022hi\u0022, false, 20.321, 4)\u0060,\nuse \u0060printfn\u0060 and the tuple to print the following string\nto standard output:\n\u0060\u0022hi teacher, my False knowledge implies that 4%=0020.1\u0022\u0060\n\n[String formatting](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/plaintext-formatting#format-specifiers-for-printf) documentation will be useful. \n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: printfnStringInterpolation, define-output: printfnStringInterpolation ***)\nlet (xString, xBool, xFloat, xInt) = (\u0022hi\u0022, false, 20.321, 4)\n(*** condition:html, include:printfnStringInterpolation ***)\n(*** condition:html, include-fsi-output:printfnStringInterpolation ***)\n\n(**\nUsing string interpolation\n*)\n\n(*** define: printfnStringInterpolation1, define-output: printfnStringInterpolation1 ***)\nprintfn $\u0022{xString} teacher, my {xBool} knowledge implies that {xInt}%%=%06.1f{xFloat}\u0022\n(*** condition:html, include:printfnStringInterpolation1 ***)\n(*** condition:html, include-output:printfnStringInterpolation1 ***)\n\n(**\nUsing old-style printfn\n*)\n\n(*** define: printfnStringInterpolation2, define-output: printfnStringInterpolation2 ***)\nprintfn \u0022%s teacher, my %b knowledge implies that %i%%=%06.1f\u0022 xString xBool xInt xFloat\n(*** condition:html, include:printfnStringInterpolation2 ***)\n(*** condition:html, include-output:printfnStringInterpolation2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nGiven \u0060returns : ReturnOb []\u0060, calculate the arithmetic average return \nfor every symbol each month.\nGive the result as a \u0060ReturnOb []\u0060 where the date is the last date for the symbol\neach month.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: arithmeticReturn, define-output: arithmeticReturn ***)\n\nreturns\n|\u003E Array.groupBy(fun x -\u003E x.Symbol, x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun ((symbol, _year, _month), xs) -\u003E\n    { Symbol = symbol \n      Date = xs |\u003E Array.map(fun x -\u003E x.Date) |\u003E Array.max \n      Return = xs|\u003E Array.averageBy(fun x -\u003E x.Return) })\n\n(*** condition:html, include:arithmeticReturn ***)\n(*** condition:html, include-fsi-output:arithmeticReturn ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nGiven \u0060returns : ReturnOb []\u0060, calculate the monthly return \nfor every symbol each month.\nGive the result as a \u0060ReturnOb []\u0060 where the date is the last date for the symbol\neach month. \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: monthlyReturn, define-output: monthlyReturn ***)\n\nreturns\n|\u003E Array.groupBy(fun x -\u003E x.Symbol, x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun ((symbol, _year, _month), xs) -\u003E\n    let monthReturnPlus1 = (1.0, xs) ||\u003E Array.fold(fun acc x -\u003E acc * (1.0 \u002B x.Return))\n    { Symbol = symbol \n      Date = xs |\u003E Array.map(fun x -\u003E x.Date) |\u003E Array.max \n      Return =  monthReturnPlus1 - 1.0 })\n\n(*** condition:html, include:monthlyReturn ***)\n(*** condition:html, include-fsi-output:monthlyReturn ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nGiven \u0060returns : ReturnOb []\u0060, calculate the standard deviation of daily returns\nfor every symbol each month.\nGive the result as a \u0060ValueOb []\u0060 where the date in each \u0060ValueOb\u0060 is the last date for the symbol\neach month. \n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: monthlyStdDev, define-output: monthlyStdDev ***)\n\nreturns\n|\u003E Array.groupBy(fun x -\u003E x.Symbol, x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun ((symbol, _year, _month), xs) -\u003E\n    let sd = xs |\u003E stDevBy(fun x -\u003E x.Return)\n    { Symbol = symbol \n      Date = xs |\u003E Array.map(fun x -\u003E x.Date) |\u003E Array.max \n      Value =  sd })\n\n(*** condition:html, include:monthlyStdDev ***)\n(*** condition:html, include-fsi-output:monthlyStdDev ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 8\nGiven \u0060returns : ReturnOb []\u0060, calculate the standard deviation of daily returns\nfor every symbol using rolling 3 day windows.\nGive the result as a \u0060ValueOb []\u0060 where the date in each \u0060ValueOb\u0060 is the last date for the symbol\nin the window. \n*)\n\n(*** include-it-raw:preDetails ***)\n\n(***define:rollingStdDev, define-output:rollingStdDev ***)\nreturns\n|\u003E Array.groupBy(fun x -\u003E x.Symbol)\n|\u003E Array.collect(fun (_symbol, xs) -\u003E\n    xs\n    |\u003E Array.sortBy(fun x -\u003E x.Date)\n    |\u003E Array.windowed 3\n    |\u003E Array.map(fun ys -\u003E \n        let last = ys |\u003E Array.last \n        { Symbol = last.Symbol\n          Date = last.Date\n          Value = ys |\u003E stDevBy(fun x -\u003E x.Return)}))\n(***condition:html,include:rollingStdDev ***)\n(***condition:html,include-fsi-output:rollingStdDev ***)\n\n(**\nBreaking this answer down,\nIf you\u0027re unsure, it\u0027s helpful to work through things step by step.\nthen build up from there.\n*)\n\n(*** define: rollingStdDev1, define-output: rollingStdDev1 ***)\nlet groups = \n    returns\n    |\u003E Array.groupBy(fun x -\u003E x.Symbol)\n(***condition:html,include:rollingStdDev1 ***)\n(***condition:html,include-fsi-output:rollingStdDev1 ***)\n\n(*** define: rollingStdDev2, define-output: rollingStdDev2 ***)\nlet firstGroup = groups |\u003E Array.item 0 // or groups |\u003E Array.head\nlet firstSymbol, firstObs = firstGroup // like let a,b = (1,2)\nlet windowedFirstObs = \n    firstObs\n    |\u003E Array.sortBy(fun x -\u003E x.Date)\n    |\u003E Array.windowed 3\nlet firstWindow = windowedFirstObs.[0]\nlet lastDayOfFirstWindow = firstWindow |\u003E Array.last\nlet firstWindowReturnStdDev = firstWindow |\u003E stDevBy(fun x -\u003E x.Return)\nlet firstWindowResult =\n    { Symbol = lastDayOfFirstWindow.Symbol \n      Date = lastDayOfFirstWindow.Date\n      Value = firstWindowReturnStdDev }\n(***condition:html,include:rollingStdDev2 ***)\n(***condition:html,include-fsi-output:rollingStdDev2 ***)\n\n(**\nNow take the inner-most code operating on a single window\nand make a function by copying and pasting inside a function.\noften using more general variable names\n*)\n\n(*** define: rollingStdDev3, define-output: rollingStdDev3 ***)\nlet resultForWindow window =\n    let lastDay = window |\u003E Array.last\n    let stddev = window |\u003E stDevBy(fun x -\u003E x.Return)\n    { Symbol = lastDay.Symbol \n      Date = lastDay.Date\n      Value = stddev }\n(***condition:html,include:rollingStdDev3 ***)\n(***condition:html,include-fsi-output:rollingStdDev3 ***)\n\n(**\ntest it on your window\n*)\n\n(*** define: rollingStdDev4, define-output: rollingStdDev4 ***)\nlet firstWindowFunctionResult = resultForWindow firstWindow\n(***condition:html,include:rollingStdDev4 ***)\n(***condition:html,include-fsi-output:rollingStdDev4 ***)\n\n(**\ncheck\n*)\n\n(*** define: rollingStdDev5, define-output: rollingStdDev5 ***)\nfirstWindowResult = firstWindowFunctionResult // evaluates to true\n(***condition:html,include:rollingStdDev5 ***)\n(***condition:html,include-fsi-output:rollingStdDev5 ***)\n\n(**\nnow a function to create the windows\n*)\n\n(*** define: rollingStdDev6, define-output: rollingStdDev6 ***)\nlet createWindows (days: ReturnOb array) =\n    days\n    |\u003E Array.sortBy(fun day -\u003E day.Date)\n    |\u003E Array.windowed 3\n(***condition:html,include:rollingStdDev6 ***)\n(***condition:html,include-fsi-output:rollingStdDev6 ***)\n\n(**\ncheck\n*)\n\n(*** define: rollingStdDev7, define-output: rollingStdDev7 ***)\n(createWindows firstObs) = windowedFirstObs // evaluates to true\n(***condition:html,include:rollingStdDev7 ***)\n(***condition:html,include-fsi-output:rollingStdDev7 ***)\n\n(**\nso now we can do\n*)\n\n(*** define: rollingStdDev8, define-output: rollingStdDev8 ***)\nfirstObs\n|\u003E createWindows\n|\u003E Array.map resultForWindow\n(***condition:html,include:rollingStdDev8 ***)\n(***condition:html,include-fsi-output:rollingStdDev8 ***)\n\n(**\nCool, now first obs was the obs from the first group.\nwe could do function to operate on a group.\nour group is a tuple of \u0060(string,ReturnObs array)\u0060.\nWe\u0027re not going to use the \u0060string\u0060 variable, so we\u0027ll preface it\nwith _ to let the compiler know we\u0027re leaving it out o purpose.\nthe _ is not necessary but it\u0027s good practice\n*)\n\n(*** define: rollingStdDev9, define-output: rollingStdDev9 ***)\nlet resultsForGroup (_symbol, xs) =\n    xs\n    |\u003E createWindows\n    |\u003E Array.map resultForWindow\n(***condition:html,include:rollingStdDev9 ***)\n(***condition:html,include-fsi-output:rollingStdDev9 ***)\n\n(**\ntest it on the first group\n*)\n\n(*** define: rollingStdDev10, define-output: rollingStdDev10 ***)\nresultsForGroup firstGroup\n(***condition:html,include:rollingStdDev10 ***)\n(***condition:html,include-fsi-output:rollingStdDev10 ***)\n\n(**\nnow make the group and apply my \ngroup function to each group\n*)\n\n(*** define: rollingStdDev11, define-output: rollingStdDev11 ***)\nlet resultsForEachGroup =\n    returns\n    |\u003E Array.groupBy(fun x -\u003E x.Symbol)\n    |\u003E Array.map resultsForGroup\n(***condition:html,include:rollingStdDev11 ***)\n(***condition:html,include-fsi-output:rollingStdDev11 ***)\n\n(**\nOkay, but this is an array of \u0060ValueOb arrays\u0060 (that\u0027s what \u0060ValueOb [ ][ ]\u0060 means).\nWhat happened is that I had an array of groups, and then I transformed each group.\nso it\u0027s still one result per group. For instance\n*)\n\n(*** define: rollingStdDev12, define-output: rollingStdDev12 ***)\nresultsForEachGroup.[0]\n(***condition:html,include:rollingStdDev12 ***)\n(***condition:html,include-fsi-output:rollingStdDev12 ***)\n\n(**\nis the first group of results\n*)\n\n(*** define: rollingStdDev13, define-output: rollingStdDev13 ***)\nresultsForEachGroup.[1]\n(***condition:html,include:rollingStdDev13 ***)\n(***condition:html,include-fsi-output:rollingStdDev13 ***)\n\n(**\nis the second group. I don\u0027t want an array of arrays.\nI just want one array of value obs. So \u0060concat\u0060 them.\n*)\n\n(*** define: rollingStdDev14, define-output: rollingStdDev14 ***)\nlet resultsForEachGroupConcatenated =\n    resultsForEachGroup |\u003E Array.concat\n(***condition:html,include:rollingStdDev14 ***)\n(***condition:html,include-fsi-output:rollingStdDev14 ***)\n\n(**\nwhat\u0027s the first thing in the array?\n*)\n\n(*** define: rollingStdDev15, define-output: rollingStdDev15 ***)\nresultsForEachGroupConcatenated.[0]  \n(***condition:html,include:rollingStdDev15 ***)\n(***condition:html,include-fsi-output:rollingStdDev15 ***)\n\n(**\n\u0060Collect\u0060 does the \u0060map\u0060 and \u0060concat\u0060 in one step.\n*)\n\n(*** define: rollingStdDev16, define-output: rollingStdDev16 ***)\nlet resultsForEachGroupCollected =\n    returns\n    |\u003E Array.groupBy(fun x -\u003E x.Symbol)\n    |\u003E Array.collect resultsForGroup \n(***condition:html,include:rollingStdDev16 ***)\n(***condition:html,include-fsi-output:rollingStdDev16 ***)\n\n(**\ncheck, this should evaluate to \u0060true\u0060\n*)\n\n(*** define: rollingStdDev17, define-output: rollingStdDev17 ***)\nresultsForEachGroupConcatenated.[0] = resultsForEachGroupCollected.[0]\n(***condition:html,include:rollingStdDev17 ***)\n(***condition:html,include-fsi-output:rollingStdDev17 ***)\n\n(**\nwhy did I write the answer using an anonymous function instead of functions like this?\nI use reusable functions for something I\u0027m going to use multiple times.\nIf it\u0027s something I\u0027ll do once, and it\u0027s not too many lines, then I use\nthe anonymous lambda function. As you get more experience, you can code using\nthe type signatures to tell you what everything is. And I don\u0027t actually\nhave to running it step by step.\nhowever, starting out especially, I think you\u0027ll find it helpful\nto kinda break things down like I did here.  \nAnother way you can do it, similar to the first answer using\nan anonymous lambda function, but now we\u0027ll do it with fewer\nnested arrays by concatenating/collecting the windows\ninto the parent array before doing the standard deviations.\n*)\n\n(*** define: rollingStdDev18, define-output: rollingStdDev18 ***)\nlet m2Groups =\n    returns\n    |\u003E Array.groupBy(fun x -\u003E x.Symbol)\n\nlet m2GroupsOfWindows =\n    m2Groups\n    |\u003E Array.map(fun (symbol, xs) -\u003E \n        xs\n        |\u003E Array.sortBy(fun x -\u003E x.Date)\n        |\u003E Array.windowed 3\n    )\n(***condition:html,include:rollingStdDev18 ***)\n(***condition:html,include-fsi-output:rollingStdDev18 ***)\n\n(**\nfirst group of windows\n*)\n\n(*** define: rollingStdDev19, define-output: rollingStdDev19 ***)\nm2GroupsOfWindows.[0]    \n(***condition:html,include:rollingStdDev19 ***)\n(***condition:html,include-fsi-output:rollingStdDev19 ***)\n\n(**\nsecond group of windows\n*)\n\n(*** define: rollingStdDev20, define-output: rollingStdDev20 ***)\nm2GroupsOfWindows.[1]    \n(***condition:html,include:rollingStdDev20 ***)\n(***condition:html,include-fsi-output:rollingStdDev20 ***)\n\n(**\n Now concatenate the windows.\n*)\n\n(*** define: rollingStdDev21, define-output: rollingStdDev21 ***)\nlet m2GroupsOfWindowsConcatenated = m2GroupsOfWindows |\u003E Array.concat  \n(***condition:html,include:rollingStdDev21 ***)\n(***condition:html,include-fsi-output:rollingStdDev21 ***)\n\n(**\nsame as if I\u0027d used collect instead of map and then concat\n*)\n\n(*** define: rollingStdDev22, define-output: rollingStdDev22 ***)\nlet m2GroupsOfWindowsCollected =\n    m2Groups\n    |\u003E Array.collect(fun (symbol, xs) -\u003E \n        xs\n        |\u003E Array.sortBy(fun x -\u003E x.Date)\n        |\u003E Array.windowed 3 \n    )\n(***condition:html,include:rollingStdDev22 ***)\n(***condition:html,include-fsi-output:rollingStdDev22 ***)\n\n(**\ncompare them\n*)\n\n(*** define: rollingStdDev23, define-output: rollingStdDev23 ***)\nlet m2FirstConcatenated = m2GroupsOfWindowsConcatenated.[0]    \nlet m2FirstCollected = m2GroupsOfWindowsCollected.[0]\nm2FirstCollected = m2FirstConcatenated // true. \n\n(***condition:html,include:rollingStdDev23 ***)\n(***condition:html,include-fsi-output:rollingStdDev23 ***) \n\n(**\nIf they\u0027re not true, make sure they\u0027re sorted the same before you take the first obs.\n*)\n\n(**\nNow, standard deviations of the windows\u0027 returns\n*)\n\n(*** define: rollingStdDev24, define-output: rollingStdDev24 ***)\nlet m2Result =\n    m2GroupsOfWindowsCollected\n    |\u003E Array.map(fun window -\u003E \n        let lastDay = window |\u003E Array.last \n        { Symbol = lastDay.Symbol\n          Date = lastDay.Date\n          Value = window |\u003E stDevBy(fun x -\u003E x.Return )})\n\n(***condition:html,include:rollingStdDev24 ***)\n(***condition:html,include-fsi-output:rollingStdDev24 ***) \n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution."},{"uri":"/Teaching/quizzes/fundamentals-PracticeQuiz.html","title":"Fundamentals","content":"(**\n---\ntitle: Fundamentals\ncategory: Practice Quizzes\ncategoryindex: 1\nindex: 1\n---\n*)\n\n(**\n[![Binder](../images/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../images/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../images/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\n## Question 1\nCalculate \u00603.0\u0060 to the power of \u00604.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: threePowerFour, define-output: threePowerFour ***)\n\n3.0 ** 4.0\n\n(*** condition:html, include:threePowerFour ***)\n(*** condition:html, include-fsi-output:threePowerFour ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nAssign the integer \u00601\u0060 to a value called \u0060a\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: Assign1toA, define-output: Assign1toA ***)\n\nlet a = 1\n\n(*** condition:html, include:Assign1toA ***)\n(*** condition:html, include-fsi-output:Assign1toA ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nWrite a function named \u0060add3\u0060 that adds \u00603.0\u0060 to any \u0060float\u0060 input.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: add3Function, define-output: add3Function ***)\n\nlet add3 x = x \u002B 3.0\n\n(*** condition:html, include:add3Function ***)\n(*** condition:html, include-fsi-output:add3Function ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nGiven a tuple \u0060(1.0,2.0)\u0060, assign the second element to a value named \u0060b\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: assignSndTob, define-output: assignSndTob ***)\nlet b = snd (1.0, 2.0)\n(*** condition:html, include: assignSndTob ***)\n(*** condition:html, include-fsi-output: assignSndTob ***)\n\n(**\nor\n*)\n\n(*** define: assignSndTob1, define-output: assignSndTob1 ***)\nlet (_, b1) = (1.0, 2.0)\n(*** condition:html, include: assignSndTob1 ***)\n(*** condition:html, include-fsi-output: assignSndTob1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nCreate a tuple where the first, second, and third elements are \u0060\u0022a\u0022\u0060, \u00601\u0060, and \u00602.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: createTuple, define-output: createTuple ***)\n\n(\u0022a\u0022, 1, 2.0)\n\n(*** condition:html, include:createTuple ***)\n(*** condition:html, include-fsi-output:createTuple ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nDefine a record type named \u0060Record1\u0060 that has a \u0060string\u0060 \u0060Id\u0060 field and a \u0060float Y\u0060 field.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: RecordType1, define-output: RecordType1 ***)\n\ntype Record1 = { Id : string; Y : float }\n\n(*** condition:html, include:RecordType1 ***)\n(*** condition:html, include-fsi-output:RecordType1 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nGiven the type signature \u0060val a : float = 2.0\u0060, what is the type of value a? \n*)\n\n(*** include-it-raw:preDetails ***)\n\n(** \nfloat\n*)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your answer here, see website for solution.\n\n\n(**\n## Question 8\nCreate a record type named \u0060Record2\u0060. It should have two integer fields \u0060X\u0060 and \u0060Y\u0060. Create an instance of the record where \u0060X = 4\u0060 and \u0060Y = 2\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: RecordType2, define-output: RecordType2 ***)\n\ntype Record2 = { X : int; Y : int }\n{ X = 4; Y = 2}\n\n(*** condition:html, include:RecordType2 ***)\n(*** condition:html, include-fsi-output:RecordType2 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 9\nExplain why this expression gives an error when you try to run it: \u00604 \u002B 7.0\u0060 \n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\n\nBecause 4 is an integer and 7.0 is a float. Addition is defined on values with the same type.\nThe two values need to either both be integers or both be floats.\n*)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your answer here, see website for solution.\n\n\n(**\n## Question 10\nCreate an \u0060array\u0060 where the elements are \u00601\u0060, \u00602\u0060, and \u00603\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: array, define-output: array ***)\n[| 1; 2; 3 |]\n(*** condition:html, include: array ***)\n(*** condition:html, include-fsi-output: array ***)\n\n(**\nor\n*)\n\n(*** define: array1, define-output: array1 ***)\n[| 1 .. 3 |]\n(*** condition:html, include: array1 ***)\n(*** condition:html, include-fsi-output: array1 ***)\n\n(**\nor\n*)\n\n(*** define: array2, define-output: array2 ***)\n[| for i = 1 to 3 do i |]\n(*** condition:html, include: array2 ***)\n(*** condition:html, include-fsi-output: array2 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 11\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Pass it to \u0060List.map\u0060 and use an anonymous function to divide each number by \u00603.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: List1, define-output: List1 ***)\n\n[ 1.0 .. 10.0]\n|\u003E List.map (fun x -\u003E x / 3.0)\n\n(*** condition:html, include:List1 ***)\n(*** condition:html, include-fsi-output:List1 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 12\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Group the elements based on whether the elements are greater than or equal to \u00604.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listGroupBy, define-output: listGroupBy ***)\n\n[ 1.0 .. 10.0]\n|\u003E List.groupBy (fun x -\u003E x \u003E= 4.0)\n\n(*** condition:html, include:listGroupBy ***)\n(*** condition:html, include-fsi-output:listGroupBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 13\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Filter it so that you are left with the elements \u0060\u003E 5.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listFilter, define-output: listFilter ***)\n\n[ 1.0 .. 10.0]\n|\u003E List.filter (fun x -\u003E x \u003E 5.0)\n\n(*** condition:html, include:listFilter ***)\n(*** condition:html, include-fsi-output:listFilter ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 14\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Use \u0060List.groupBy\u0060 to group the elements based on if they\u0027re \u0060\u003E= 5.0\u0060. Then use \u0060List.map\u0060 to get the maxiumum element that is \u0060\u003C 5.0\u0060 and the minimum value that is \u0060\u003E= 5.0\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listGroupMaxAndMin, define-output: listGroupMaxAndMin ***)\n\n[ 1.0 .. 10.0]\n|\u003E List.groupBy(fun x -\u003E x \u003E= 5.0)\n|\u003E List.map(fun (gt5, xs) -\u003E \n    if gt5 then List.min xs else List.max xs)\n\n(*** condition:html, include:listGroupMaxAndMin ***)\n(*** condition:html, include-fsi-output:listGroupMaxAndMin ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 15\nTake a \u0060list\u0060 containing floats \u00601.0 .. 10.0\u0060. Use functions from the List module to sort it in descending order. Then take the 3rd element of the reversed list and add \u00607.0\u0060 to it.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: listSort, define-output: listSort ***)\n\n[1.0 .. 10.0]\n|\u003E List.sortByDescending id\n|\u003E List.item 2\n|\u003E fun x -\u003E x \u002B 7.0\n\n\n(*** condition:html, include:listSort ***)\n(*** condition:html, include-fsi-output:listSort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n"},{"uri":"/Teaching/quizzes/portfolios-PracticeQuiz.html","title":"Portfolios","content":"(**\n---\ntitle: Portfolios\ncategory: Practice Quizzes\ncategoryindex: 1\nindex: 6\n---\n*)\n\n(**\n[![Binder](../images/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../images/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../images/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\n# Some good things to reference\n\n[Anonymous Records](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/anonymous-records#syntax). You can read the above link for details, but the point of these is quite simple.\n\nRecords have been our main type for holding data for an observation. We\u0027ve typically defined these ahead of time with a name before using them. This is good for important types that you will use frequently.\n\nIf you\u0027re using a particular record in only a few lines of code, then it can feel cumbersome to define the type beforehand. Anonymous records are a good solution in these circumstances. They are records that you can essentially use like regular records that we\u0027ve been using, but you don\u0027t have to define the name of the record ahead of time.\n\nI rarely use anonymous records, but you might find them useful for exploratory data manipulation. They\u0027re also kind of nice for these short problems because I don\u0027t need to define a record for each problem.\n*)\n\n(**\n# Anonymous records\n*)\n\n(**\n## Question 1\n\n1. Create a *record* named \u0060ExampleRec\u0060 that has an \u0060X\u0060 field of type int and a \u0060Y\u0060 field of type int. Create an example \u0060ExampleRec\u0060 and assign it to a value named \u0060r\u0060.\n2. Create an *anonymous record* that has an \u0060X\u0060 field of type int and a \u0060Y\u0060 field of type int. Create an example of the anonymous record and assign it to a value named \u0060ar\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nA regular named record: \n*)\n\n(*** define: ExampleRec, define-output: ExampleRec ***)\ntype ExampleRec = { X : int; Y : int }\n\nlet r = { X = 1; Y = 2}\n(*** condition:html, include:ExampleRec ***)\n(*** condition:html, include-fsi-output:ExampleRec ***)\n\n(**\nAn anonymous record. The difference is:\n\n1. We did not define the type ahead of time.\n2. We put the pipe symbol \u0060\u0022|\u003E\u0022\u0060 inside the curly braces.\n*)\n\n(*** define: ExampleRec1, define-output: ExampleRec1 ***)\nlet ar = {| X = 1; Y = 2|}\n(*** condition:html, include:ExampleRec1 ***)\n(*** condition:html, include-fsi-output:ExampleRec1 ***)\n\n(**\nNote that they are not the same type, so if you\ncompare them they will be different even though\nthe X and Y fields have the same values.\nFor example, running \u0060r = ar\u0060 \nwill give a compiler error.\n*)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nImagine you have this array\n*)\n\nopen System\ntype ArExample = { Date : DateTime; Value: float}\nlet arr = [|{ Date = DateTime(1990,1,1); Value = 1.25}\n            { Date = DateTime(1990,1,2); Value = 2.25}\n            { Date = DateTime(1991,1,1); Value = 3.25} |]\n\n(**\n1. Group the observations by a tuple of \u0060(year,month)\u0060 and find the \nminimum value for each group. Report the result as a tuple of the group\nand the minimum value [so it will be \u0060((year, month), minValue)\u0060].\n2. Now, the same thing with anonymous records.\nGroup the observations by an Anonymous Record \u0060{| Year = year; Month= month|}\u0060 and find the \nminimum value for each group. Report the result as an Anonymous record with a Group\nfield for the group and a value field for the minimum value [so it will be\n\u0060{| Group = {| Year = year; Month= month|}; Value = minValue |}\u0060].\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nhere I will explicitly put year and month in the final result\n*)\n\n(*** define: RecordsAndTransformations, define-output: RecordsAndTransformations ***)\narr \n|\u003E Array.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun (group, xs) -\u003E\n    let year, month = group // Explicitly access year, month; same as let a,b = (1,2)\n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    (year, month), minValue) // explicitly put it in the result\n(*** condition:html, include:RecordsAndTransformations ***)\n(*** condition:html, include-fsi-output:RecordsAndTransformations ***)\n\n(**\nhere I will explicitly put year and month in the final result,\nbut I will deconstruct them using pattern matching in the\nfunction input\n*)\n\n(*** define: RecordsAndTransformations1, define-output: RecordsAndTransformations1 ***)\narr \n|\u003E Array.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun ((year, month), xs) -\u003E // Explicitly pattern match year, month in function input\n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    (year, month), minValue) // explicitly put it in the result\n(*** condition:html, include:RecordsAndTransformations1 ***)\n(*** condition:html, include-fsi-output:RecordsAndTransformations1 ***)\n\n(**\nor\nsince I\u0027m just returning the grouping variable, there\u0027s really\nno need to deconstruct it into \u0060(year, month)\u0060 at any point.\n*)\n\n(*** define: RecordsAndTransformations2, define-output: RecordsAndTransformations2 ***)\narr \n|\u003E Array.groupBy(fun x -\u003E x.Date.Year, x.Date.Month)\n|\u003E Array.map(fun (group, xs) -\u003E // match group to (year,month) together\n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    group, minValue)\n(*** condition:html, include:RecordsAndTransformations2 ***)\n(*** condition:html, include-fsi-output:RecordsAndTransformations2 ***)\n\n(**\nNow using anonymous records\nThis is where anonymous records can be useful.\nFor example, sometimes grouping by many things, \nusing anonymous records like this make it more clear what the different\ngrouping variables are because they have names.\nIt\u0027s like a middle ground between tuples with no clear naming structure\nand regular named records that are very explicit.\n*)\n\n(*** define: RecordsAndTransformations3, define-output: RecordsAndTransformations3 ***)\narr \n|\u003E Array.groupBy(fun x -\u003E {| Year = x.Date.Year; Month = x.Date.Month |})\n|\u003E Array.map(fun (group, xs) -\u003E \n    let year, month = group.Year, group.Month // explicit deconstruct \n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    {| Group = {| Year = year; Month = month|}; Value = minValue |})\n(*** condition:html, include:RecordsAndTransformations3 ***)\n(*** condition:html, include-fsi-output:RecordsAndTransformations3 ***)\n\n(**\nor, do the same thing by returning the whole group without deconstructing\n*)\n\n(*** define: RecordsAndTransformations4, define-output: RecordsAndTransformations4 ***)\narr \n|\u003E Array.groupBy(fun x -\u003E {| Year = x.Date.Year; Month = x.Date.Month |})\n|\u003E Array.map(fun (group, xs) -\u003E \n    let minValue = xs |\u003E Array.map(fun x -\u003E x.Value)|\u003E Array.min\n    {| Group = group; Value = minValue |})\n(*** condition:html, include:RecordsAndTransformations4 ***)\n(*** condition:html, include-fsi-output:RecordsAndTransformations4 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Portfolio Returns\n*)\n\n(**\n## Question 1\nImagine that you have the following positions in your portfolio.\nFor each position you have a weight and a return.\nWhat is the return of the entire portfolio?\n*)\n\ntype PortReturnPos = { Id: string;  Weight: float; Return: float}\nlet stockPos = { Id = \u0022stock\u0022; Weight = 0.25; Return = 0.1 }\nlet bondPos = { Id = \u0022bond\u0022; Weight = 0.75; Return = 0.05}\n\n(**\n1. Group the observations by a tuple of \u0060(year,month)\u0060 and find the \nminimum value for each group. Report the result as a tuple of the group\nand the minimum value [so it will be \u0060((year, month), minValue)\u0060].\n2. Now, the same thing with anonymous records.\nGroup the observations by an Anonymous Record \u0060{| Year = year; Month= month|}\u0060 and find the \nminimum value for each group. Report the result as an Anonymous record with a Group\nfield for the group and a value field for the minimum value [so it will be\n\u0060{| Group = {| Year = year; Month= month|}; Value = minValue |}\u0060].\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nRemember that portfolio returns are a weighted average\nof the returns of the stocks in the portfolio. The weights\nare the position weights.\n*)\n\n(*** define: PortfolioRet1, define-output: PortfolioRet1 ***)\nlet stockAndBondPort = \n    stockPos.Weight*stockPos.Return \u002B bondPos.Weight*bondPos.Return\n(*** condition:html, include:PortfolioRet1 ***)\n(*** condition:html, include-fsi-output:PortfolioRet1 ***)\n\n(**\nor, doing the multiplication and summation with collections\n*)\n\n(*** define: PortfolioRet2, define-output: PortfolioRet2 ***)\nlet weightXreturn =\n    [|stockPos;bondPos|]\n    |\u003E Array.map(fun pos -\u003E pos.Weight*pos.Return)\n(*** condition:html, include:PortfolioRet2 ***)\n(*** condition:html, include-fsi-output:PortfolioRet2 ***)\n\n(**\nnow sum\n*)\n\n(*** define: PortfolioRet3, define-output: PortfolioRet3 ***)\nlet stockAndBondPort2 = weightXreturn |\u003E Array.sum\n(*** condition:html, include:PortfolioRet3 ***)\n(*** condition:html, include-fsi-output:PortfolioRet3 ***)\n\n(**\ncheck\n*)\n\n(*** define: PortfolioRet4, define-output: PortfolioRet4 ***)\nstockAndBondPort = stockAndBondPort2 // evaluates to true\n(*** condition:html, include:PortfolioRet4 ***)\n(*** condition:html, include-fsi-output:PortfolioRet4 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nImagine that you have the following positions in your portfolio.\nFor each position you have a weight and a return.\nWhat is the return of the entire portfolio?\n*)\n\n(*** define: Positions ***)\nlet positions =\n    [|{ Id = \u0022stock\u0022; Weight = 0.25; Return = 0.12 }\n      { Id = \u0022bond\u0022; Weight = 0.25; Return = 0.22 }\n      { Id = \u0022real-estate\u0022; Weight = 0.5; Return = -0.15 } |]\n(*** condition:html, include:Positions ***)\n\n(*** include-it-raw:preDetails ***)\n(*** define: EntirePortRet, define-output: EntirePortRet ***)\n\nlet threeAssetPortfolioReturn =\n    positions\n    |\u003E Array.map(fun pos -\u003E pos.Weight*pos.Return)\n    |\u003E Array.sum\n\n(*** condition:html, include:EntirePortRet ***)\n(*** condition:html, include-fsi-output:EntirePortRet ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nImagine that you have the following positions in your portfolio.\nFor each position you have a weight and a return.\nWhat is the return of the entire portfolio?\n*)\n\n(*** define: positionsWithShort ***)\nlet positionsWithShort =\n    [|{ Id = \u0022stock\u0022; Weight = 0.25; Return = 0.12 }\n      { Id = \u0022bond\u0022; Weight = -0.25; Return = 0.22 }\n      { Id = \u0022real-estate\u0022; Weight = 1.0; Return = -0.15 } |]\n(*** condition:html, include:positionsWithShort ***)\n\n(*** include-it-raw:preDetails ***)\n(*** define: EntirePortRetWithShort, define-output: EntirePortRetWithShort ***)\n\nlet positionsWithShortReturn =\n    positionsWithShort\n    |\u003E Array.map(fun pos -\u003E pos.Weight*pos.Return)\n    |\u003E Array.sum\n\n\n(*** condition:html, include:EntirePortRetWithShort ***)\n(*** condition:html, include-fsi-output:EntirePortRetWithShort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n# Sharpe Ratios\n*)\n\n(**\n## Question 1\nImagine that you have the following array of *annual* returns in\nexcess of the risk-free rate. What is the *annualized* Sharpe ratio?\n*)\n\nlet rets = [| 0.1; -0.4; 0.2; 0.15; -0.03 |]\n\n(**\nNote that the units are such that 0.1 is 10%.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: FStats, define-output: FStats ***)\n#r \u0022nuget: FSharp.Stats\u0022\nopen FSharp.Stats\n(*** condition:html, include:FStats ***)\n\n(**\nwe get \u0060stDev\u0060 from \u0060FSharp.Stats\u0060\nthere is only a \u0060Seq.stDev\u0060, not \u0060Array.stDev\u0060.\nWe can use \u0060Seq.stDev\u0060 with array because you\ncan pipe any collection to a \u0060Seq\u0060.\n*)\n\n(*** define: AnnualizedSR, define-output: AnnualizedSR ***)\nlet retsAvg = rets |\u003E Array.average\nlet retsStdDev = rets |\u003E Seq.stDev \nlet retsSharpeRatio = retsAvg/retsStdDev\n(*** condition:html, include:AnnualizedSR ***)\n(*** condition:html, include-fsi-output:AnnualizedSR ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nImagine that you have the following array of *monthly* returns in\nexcess of the risk-free rate. What is the *annualized* Sharpe ratio?\n\n\u0060\u0060\u0060fsharp\nlet rets = [| 0.1; -0.4; 0.2; 0.15; -0.03 |]\n//Note that the units are such that 0.1 is 10%.\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nremember that to annualize an arithmetic return,\nwe do \u0060return *\u0060 (# compounding periods per year)\nto annualize a standard deviation, \nwe do \u0060sd * sqrt\u0060(# compounding periods per year)\n*)\n\n(*** define: MonthlyRetAnnualSR, define-output: MonthlyRetAnnualSR ***)\nlet monthlyRetsAnnualizedAvg = 12.0*(rets |\u003E Array.average)\n(*** condition:html, include:MonthlyRetAnnualSR ***)\n(*** condition:html, include-fsi-output:MonthlyRetAnnualSR ***)\n\n(**\nor\n*)\n\n(*** define: MonthlyRetAnnualSR1, define-output: MonthlyRetAnnualSR1 ***)\nlet monthlyRetsAnnualizedAvg2 = \n    rets \n    |\u003E Array.average \n    // now we\u0027re going to use a lambda expression.\n    // this is the same idea as when we do Array.map(fun x -\u003E ...)\n    // except now we\u0027re only piping a float, not an array so\n    // we\u0027re leaving off the \u0022Array.map\u0022 \n    |\u003E (fun avg -\u003E 12.0 * avg) \n(*** condition:html, include:MonthlyRetAnnualSR1 ***)\n(*** condition:html, include-fsi-output:MonthlyRetAnnualSR1 ***)\n\n(**\nor, in two steps\n*)\n\n(*** define: MonthlyRetAnnualSR2, define-output: MonthlyRetAnnualSR2 ***)\nlet monthlyRetsAvg = rets |\u003E Array.average\nlet monthlyRetsAnnualizedAvg3 = 12.0*monthlyRetsAvg\n(*** condition:html, include:MonthlyRetAnnualSR2 ***)\n(*** condition:html, include-fsi-output:MonthlyRetAnnualSR2 ***)\n\n(**\nnow the standard deviation\n*)\n\n(*** define: MonthlyRetAnnualSR3, define-output: MonthlyRetAnnualSR3 ***)\nlet monthlyRetsAnnualizedSd = \n    rets \n    |\u003E Seq.stDev\n    |\u003E fun monthlySd -\u003E sqrt(12.0) * monthlySd\n(*** condition:html, include:MonthlyRetAnnualSR3 ***)\n(*** condition:html, include-fsi-output:MonthlyRetAnnualSR3 ***)\n\n(**\nor, in two steps\n*)\n\n(*** define: MonthlyRetAnnualSR4, define-output: MonthlyRetAnnualSR4 ***)\nlet monthlyRetsSd = rets |\u003E Seq.stDev\nlet monthlyRetsAnnualizedSd2 = sqrt(12.0)*monthlyRetsSd\n(*** condition:html, include:MonthlyRetAnnualSR4 ***)\n(*** condition:html, include-fsi-output:MonthlyRetAnnualSR4 ***)\n\n(**\nSharpeRatio\n*)\n\n(*** define: MonthlyRetAnnualSR5, define-output: MonthlyRetAnnualSR5 ***)\nlet annualizedSharpeFromMonthly =\n    monthlyRetsAnnualizedAvg / monthlyRetsAnnualizedSd\n(*** condition:html, include:MonthlyRetAnnualSR5 ***)\n(*** condition:html, include-fsi-output:MonthlyRetAnnualSR5 ***)\n\n(**\nor, since: \n$$\\frac{12.0}{sqrt(12.0) } = sqrt(12.0)$$\nthen:\n$$\\frac{monthlyRetsAvg \\times 12.0}{monthlyRetsSd \\times sqrt(12.0)} = sqrt(12.0)\\times\\frac{monthlyRetsAvg}{monthlyRetsSd}$$\n*)\n\n(*** define: MonthlyRetAnnualSR6, define-output: MonthlyRetAnnualSR6 ***)\nlet annualizedSharpeFromMonthly2 =\n    sqrt(12.0) * (monthlyRetsAvg/monthlyRetsSd)\n(*** condition:html, include:MonthlyRetAnnualSR6 ***)\n(*** condition:html, include-fsi-output:MonthlyRetAnnualSR6 ***)\n\n(**\nCheck  \nwe have to round because floating point math gives us slightly different #\u0027s\nrecall from the fundamentals lecture how floating point math is inexact.\n*)\n\n(*** define: MonthlyRetAnnualSR7, define-output: MonthlyRetAnnualSR7 ***)\nMath.Round(annualizedSharpeFromMonthly,6) = Math.Round(annualizedSharpeFromMonthly2,6) // true\n(*** condition:html, include:MonthlyRetAnnualSR7 ***)\n(*** condition:html, include-fsi-output:MonthlyRetAnnualSR7 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nImagine that you have the following array of *daily* returns in\nexcess of the risk-free rate. What is the *annualized* Sharpe ratio?\n\n\u0060\u0060\u0060fsharp\nlet rets = [| 0.1; -0.4; 0.2; 0.15; -0.03 |]\n//Note that the units are such that 0.1 is 10%.\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nConvention for daily is 252 trading days per year.\nso annualize daily by multiplying by \u0060sqrt(252.0)\u0060.\n*)\n\n(*** define: dailyRetAnnualSR, define-output: dailyRetAnnualSR ***)\nlet annualizedSharpeFromDaily =\n    let avgRet = rets |\u003E Array.average\n    let stdevRet = rets |\u003E Seq.stDev\n    sqrt(252.0) * (avgRet/stdevRet)\n(*** condition:html, include:dailyRetAnnualSR ***)\n(*** condition:html, include-fsi-output:dailyRetAnnualSR ***)\n\n(**\nor in multiple steps\n*)\n\n(*** define: dailyRetAnnualSR1, define-output: dailyRetAnnualSR1 ***)\nlet dailyAvgRet = rets |\u003E Array.average\nlet dailyStDevRet = rets |\u003E Seq.stDev\nlet annualizedSharpeFromDaily2 =\n    sqrt(252.0) * (dailyAvgRet/dailyStDevRet)\n(*** condition:html, include:dailyRetAnnualSR1 ***)\n(*** condition:html, include-fsi-output:dailyRetAnnualSR1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n\n"},{"uri":"/Teaching/quizzes/volatilityTiming-PracticeQuiz.html","title":"Volatility Timing Part 1","content":"(**\n---\ntitle: Volatility Timing Part 1\ncategory: Practice Quizzes\ncategoryindex: 1\nindex: 2\n---\n*)\n\n(**\n[![Binder](../images/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../images/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../images/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n\n(**\n## Question 1\nGiven the list below, filter the list so that only numbers greater than \u00602\u0060 remain.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: filter, define-output: filter ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.filter(fun x -\u003E x \u003E 2)\n\n(*** condition:html, include:filter ***)\n(*** condition:html, include-fsi-output:filter ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nGiven the list below, take elements until you find one that is greater than \u00604\u0060.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: takeWhile, define-output: takeWhile ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.takeWhile(fun x -\u003E x \u003C= 4)\n\n(*** condition:html, include:takeWhile ***)\n(*** condition:html, include-fsi-output:takeWhile ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nGiven the list below, take elements until you find one that is greater than \u00604\u0060.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: skipWhile, define-output: skipWhile ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.skipWhile(fun x -\u003E x \u003C= 4)\n\n(*** condition:html, include:skipWhile ***)\n(*** condition:html, include-fsi-output:skipWhile ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nGiven the list below, return tuples of all consecutive pairs.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: pairwise, define-output: pairwise ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.pairwise\n\n(*** condition:html, include:pairwise ***)\n(*** condition:html, include-fsi-output:pairwise ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nGiven the list below, return sliding windows of 3 consecutive observations.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: windowed, define-output: windowed ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.windowed 3\n\n(*** condition:html, include:windowed ***)\n(*** condition:html, include-fsi-output:windowed ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nGiven the list below, use \u0060scan\u0060 to return the intermediate and final cumulative sums.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: scan, define-output: scan ***)\n\n(0, [ 1; -4; 7; 2; -10])\n||\u003E List.scan (fun acc x -\u003E acc \u002B x) \n\n(*** condition:html, include:scan ***)\n(*** condition:html, include-fsi-output:scan ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 7\nGiven the list below, use \u0060fold\u0060 to return the final sum.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: fold, define-output: fold ***)\n\n(0, [ 1; -4; 7; 2; -10])\n||\u003E List.fold (fun acc x -\u003E acc \u002B x) \n\n(*** condition:html, include:fold ***)\n(*** condition:html, include-fsi-output:fold ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 8\nGiven the list below, use \u0060mapFold\u0060 to return the intermediate and final cumulative sums.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mapFold1, define-output: mapFold1 ***)\n\n(0, [ 1; -4; 7; 2; -10])\n||\u003E List.mapFold (fun acc x -\u003E acc \u002B x, acc \u002B x)\n\n(*** condition:html, include:mapFold1 ***)\n(*** condition:html, include-fsi-output:mapFold1 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 9\nGiven the list below, use \u0060mapFold\u0060 to return a tuple of\n\n1. A new list in which each element of the original list is transformed by adding \u00601\u0060 to it and then converted into a \u0060string\u0060.\n2. The final cumulative sums of the list elements.\n\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mapFold2, define-output: mapFold2 ***)\n\n(0, [ 1; -4; 7; 2; -10])\n||\u003E List.mapFold (fun acc x -\u003E string (x \u002B 1), acc \u002B x) \n\n(*** condition:html, include:mapFold2 ***)\n(*** condition:html, include-fsi-output:mapFold2 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 10\nGiven the list below, use \u0060mapFold\u0060 to return a tuple of\n*)\n\ntype R1 = { X : string; Y : int }\n\nlet r1xs =\n    [ { X = \u0022a\u0022; Y = 1 }\n      { X = \u0022b\u0022; Y = -4 }\n      { X = \u0022c\u0022; Y = 7 } \n      { X = \u0022d\u0022; Y = 2 }\n      { X = \u0022e\u0022; Y = -10 }]\n\n(**\n1. The list of records with the \u0060Y\u0060 field in each record updated to \u0060Y\u002B1\u0060\n2. The sum of the \u0060Y\u0060 fields.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: mapFold3, define-output: mapFold3 ***)\n(0, r1xs)\n||\u003E List.mapFold (fun acc x -\u003E { x with Y = x.Y\u002B1}, acc \u002B x.Y) \n(*** condition:html, include:mapFold3 ***)\n(*** condition:html, include-fsi-output:mapFold3 ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 11\nGiven the list below, sum all the elements.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: sum, define-output: sum ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.sum\n\n(*** condition:html, include:sum ***)\n(*** condition:html, include-fsi-output:sum ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 12\nGiven the list below, add \u00601\u0060 to all the elements and then calculate the sum.\n\u0060\u0060\u0060fsharp\n[ 1; -4; 7; 2; -10]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: sumBy, define-output: sumBy ***)\n\n[ 1; -4; 7; 2; -10]\n|\u003E List.sumBy(fun x -\u003E x \u002B 1)\n\n(*** condition:html, include:sumBy ***)\n(*** condition:html, include-fsi-output:sumBy ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 13\nGiven the list below, calculate the \u0060average\u0060 of the elements in the list.\n\u0060\u0060\u0060fsharp\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: average, define-output: average ***)\n\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n|\u003E List.average\n\n(*** condition:html, include:average ***)\n(*** condition:html, include-fsi-output:average ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n\n(**\n## Question 14\nGiven the list below, convert each element to a \u0060decimal\u0060 and then calculate the \u0060average\u0060 of the elements in the list.\n\n\u0060\u0060\u0060fsharp\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n\u0060\u0060\u0060\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: averageBy, define-output: averageBy ***)\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n|\u003E List.averageBy(fun x -\u003E decimal x)\n(*** condition:html, include: averageBy ***)\n(*** condition:html, include-fsi-output: averageBy ***)\n\n(**\nSince \u0060decimal\u0060 is a function that converts to\nthe \u0060decimal\u0060 type, you could also do.\nThe FSharp linter shouLd show you a blue squiggly\nin the above code telling you this.\n*)\n\n(*** define: averageBy1, define-output: averageBy1 ***)\n[ 1.0; -4.0; 7.0; 2.0; -10.0]\n|\u003E List.averageBy decimal\n(*** condition:html, include: averageBy1 ***)\n(*** condition:html, include-fsi-output: averageBy1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n"},{"uri":"/Teaching/quizzes/factors-practiceQuiz.html","title":"Factors","content":"(**\n---\ntitle: Factors\ncategory: Practice Quizzes\ncategoryindex: 1\nindex: 7\n---\n*)\n\n(**\n[![Binder](../images/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)\u0026emsp;\n[![Script](../images/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)\u0026emsp;\n[![Notebook](../images/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)\n*)\n\n(*** hide,define-output:preDetails ***)\n\u0022\u0022\u0022\n\u003Cdiv style=\u0022padding-left: 40px;\u0022\u003E\n\u003Cp\u003E \n\u003Cspan\u003E\n\u003Cdetails\u003E\n\u003Csummary\u003E\u003Cp style=\u0022display:inline\u0022\u003Eanswer\u003C/p\u003E\u003C/summary\u003E\n\n\u0022\u0022\u0022\n\n(*** hide,define-output:postDetails ***)\n\u0022\u0022\u0022\n\n\u003C/details\u003E\n\u003C/span\u003E\n\u003C/p\u003E\n\u003C/div\u003E\n\u0022\u0022\u0022\n\n(**\nOn moodle, there is a set of investment lecture notes called \u0022Finance Review\u0022. \nPlease review the Lecture-08-APT.pdf document, including the appendix. \n\nIn particular,\n\n- What do we mean by a factor?\n- The example showing how to hedge Barrick with GLD and SPY.\n- Information ratios.\n\n*)\n\n(**\nImagine you have the below returns for IBM and SPY. \nIBM\u0027s factor beta on SPY and the (constant)\nrisk-free rate are given below too.\n*)\n\ntype ReturnOb = { Time: int; Return : float }\nlet ibm =\n    [| \n        { Time = 0; Return = 0.15 }\n        { Time = 1; Return = 0.05 }\n        { Time = 2; Return = 0.01 }\n    |]\n\nlet spy =\n    [| \n        { Time = 0; Return = 0.1 }\n        { Time = 1; Return = 0.05 }\n        { Time = 2; Return = -0.02 }\n    |]    \n\nlet riskFreeRate = 0.001\nlet ibmBetaOnSpy = 1.2    \n\n\n(**\n## Question 1\nWhat are the weights on the risk-free asset and\nSPY in the portfolio that hedges IBM\u0027s exposure to\nSPY? \n\n1. Report the weight on the risk-free asset as a value named \u0060wRf\u0060 of type \u0060float\u0060. \n2. Report the weight on the SPY portfolio as a value named \u0060wSpy\u0060 of type \u0060float\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: WeightsHedgePort, define-output: WeightsHedgePort ***)\n\nlet wSpy = ibmBetaOnSpy\nlet wRf = 1.0-wSpy\n\n(*** condition:html, include:WeightsHedgePort ***)\n(*** condition:html, include-fsi-output:WeightsHedgePort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 2\nWhat are the returns for Times [0;1;2] on the portfolio \nthat hedges IBM\u0027s factor exposure to SPY? \n\n1. Report results as a value named \u0060hedgePortReturns\u0060 of type \u0060ReturnOb array\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: ReturnsHedgePort, define-output: ReturnsHedgePort ***)\n\nlet hedgePortReturns =\n    spy\n    |\u003E Array.map(fun spy -\u003E\n        { Time = spy.Time \n          Return = wSpy*spy.Return \u002B wRf*riskFreeRate })\n\n(*** condition:html, include:ReturnsHedgePort ***)\n(*** condition:html, include-fsi-output:ReturnsHedgePort ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 3\nCall the portfolio that hedges IBM\u0027s factor exposure to SPY\nthe hedge portfolio. What is the hedge portfolio\u0027s factor beta\non SPY? \n\n1. Report the answer as a value named \u0060hedgePortBetaOnSpy\u0060 of type float.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(**\nSee the lecture notes for a fuller explanation:\nFrom the portfolio return equation, the\nhedge portfolio return is:\n\n$$r_{hedgePort} = w_{Rf} \\times r_f \u002B w_{Spy}  \\times r_{Spy}$$\n$$\\iff r_{hedgePort} - r_f = (w_{Spy}  \u002B w_{Rf} - 1) \\times r_f \u002B w_{Spy}  \\times ( r_{Spy}  - r_f)$$\n$$\\iff r_{hedgePort} -  r_f = w_{Spy} \\times ( r_{Spy}  - r_f)$$\n\nSo the beta is:\n*)\n\n(*** define: BetaSPYHedgePort, define-output: BetaSPYHedgePort ***)\nlet hedgePortBetaOnSpy = ibmBetaOnSpy \n(*** condition:html, include:BetaSPYHedgePort ***)\n(*** condition:html, include-fsi-output:BetaSPYHedgePort ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 4\nWhat are the returns for Times [0;1;2] on the portfolio\nthat is long IBM and short the portfolio that hedges\nIBM\u0027s factor exposre to SPY?\n\n1. Report results as a value named \u0060longShortPortReturns\u0060 of type \u0060ReturnOb array\u0060.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: LongShortIBMRet, define-output: LongShortIBMRet ***)\n\nlet hedgePortMap =\n    // using map because it\u0027s efficient for lookups.\n    // you could use filter with such a small collection,\n    // but we\u0027ll use a Map collection so that we\n    // practice like it\u0027s the real thing.\n    hedgePortReturns\n    |\u003E Array.map(fun x -\u003E x.Time, x)\n    |\u003E Map.ofArray\n\nlet longShortPortReturns =\n    ibm\n    |\u003E Array.choose(fun ibmOb -\u003E\n        // We\u0027re using Array.choose instead of Array.map\n        // because we plan to return Some hedgeOb or None, and we\n        // want to throw away all the None cases and return just\n        // an array of the valid hedgeObs. \n        let matchingHedgeReturn = Map.tryFind ibmOb.Time hedgePortMap\n        // in this example matchingHedgeReturn will always be Some hedgeOb.\n        // But, we\u0027re using Map.tryFind and dealing with the possibility\n        // that None could happen because it\u0027s good to practice\n        // as if this were real code where bad things could happen.\n        match matchingHedgeReturn with\n        | None -\u003E None // if there\u0027s no hedge return for ibmOb.Time return None\n        | Some hedgeOb -\u003E \n            // if there is a matching hedge return for ibmOb.Time return Some ReturnOb\n            let longShort =  ibmOb.Return - hedgeOb.Return\n            Some { Time = ibmOb.Time; Return = longShort })\n\n(*** condition:html, include:LongShortIBMRet ***)\n(*** condition:html, include-fsi-output:LongShortIBMRet ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 5\nWhat is the alpha of IBM from the perspective of \na factor model that uses SPY as the only risk factor? \n\n1. Report the result as a value named \u0060alpha\u0060 of type float.\n*)\n\n(*** include-it-raw:preDetails ***)\n(*** define: Alpha, define-output: Alpha ***)\n\nlet alpha = \n    longShortPortReturns \n    |\u003E Array.averageBy(fun x -\u003E x.Return)\n\n(*** condition:html, include:Alpha ***)\n(*** condition:html, include-fsi-output:Alpha ***)\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution.\n\n\n(**\n## Question 6\nWhat is the information ratio of IBM from the perspective\nof a factor model that uses SPY as the only risk factor?\n\n1. Report the result as a value named \u0060io\u0060 of type float.\n*)\n\n(*** include-it-raw:preDetails ***)\n\n(*** define: FStats***)\n#r \u0022nuget: FSharp.Stats\u0022\nopen FSharp.Stats\n(*** condition:html, include:FStats ***)\n\n(*** define: IO, define-output: IO ***)\nlet sdHedgeReturns =\n    longShortPortReturns\n    |\u003E Array.map(fun x -\u003E x.Return )\n    |\u003E Seq.stDev\n(*** condition:html, include:IO ***)\n(*** condition:html, include-fsi-output:IO ***)\n\n(**\nIntuitively, you can think of it similar\nto the sharpe ratio of the portfolio after\nhedging out the factor risk.\n*)\n\n(*** define: IO1, define-output: IO1 ***)\nlet io = alpha / sdHedgeReturns\n(*** condition:html, include:IO1 ***)\n(*** condition:html, include-fsi-output:IO1 ***)\n\n(*** include-it-raw:postDetails ***)\n\n(*** condition:ipynb ***)\n// write your code here, see website for solution."}]